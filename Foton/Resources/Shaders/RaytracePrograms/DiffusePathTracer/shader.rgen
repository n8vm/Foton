#version 460
#extension GL_NV_ray_tracing : require
#define RAYTRACING

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/OffsetRay.hxx"
#include "Foton/Resources/Shaders/Common/LTCCommon.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"
#include "Foton/Resources/Shaders/Common/Lights.hxx"

vec3 Uncharted2Tonemap(vec3 x)
{
    x = max(x, vec3(0));
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E_ = 0.02;
	float F = 0.30;
	return max(vec3(0.0f), ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F))-E_/F);
}

void main() 
{
    if (int(gl_LaunchIDNV.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
    if (int(gl_LaunchIDNV.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;

    init_random(ivec2(gl_LaunchIDNV.xy), push.consts.frame, 0);
    float rand = random();
    
    int rand_curr = 0;//int(random(ivec2(gl_LaunchIDNV.xy), (push.consts.frame)) * PATH_TRACE_TILE_SIZE * PATH_TRACE_TILE_SIZE);
    ivec2 tile = ivec2(gl_LaunchIDNV.xy);
    // ivec2 offset_curr = ivec2(rand_curr / PATH_TRACE_TILE_SIZE, rand_curr % PATH_TRACE_TILE_SIZE);
    ivec2 offset_curr = ivec2(0); // for now commenting out. This will potentially effect the seed for gradient...
    
    /* Load primary visibility data from G Buffers */
    vec4 temp;
    ivec2 ipos = tile * PATH_TRACE_TILE_SIZE + offset_curr;

    // Seed / Luminance G Buffer
    temp = imageLoad(gbuffers[SEED_ADDR], tile);
    ivec2 pixel_seed = ivec2(temp.xy);
    int frame_seed = int(temp.z);
    init_random(pixel_seed, frame_seed, 0);

    // Position G Buffer 
    temp = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    vec3 first_position = temp.xyz;
    float first_dist = temp.w;

    // Normal G Buffer
    temp = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos);
    vec3 first_normal = normalize(temp.xyz);

    // Component IDs
    temp = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos);
    int first_entity_id = int(temp.r);
    int first_material_id = int(temp.g);
    int first_transform_id = int(temp.b);
    int first_light_id = int(temp.a);

    // UV G Buffer
    temp = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ipos);
    vec2 first_uv = temp.xy;

    // Raw albedo
    temp = imageLoad(gbuffers[DIFFUSE_COLOR_ADDR], ipos);
    vec4 first_albedo = temp;

    // bad precision in position g buffer... getting lots of self intersections...
    first_position += first_normal * .01; 
    
    /* Next, Compute ray origin and direction */
    int max_path_depth = int(push.consts.parameter1);
    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    int multiview_idx = 0; //push.consts.viewIndex;
    mat4 projinv = camera.multiviews[multiview_idx].projinv;
    mat4 viewinv = camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv;
    vec2 pixel_center = vec2(ipos.xy) + vec2(random(), random()) * .5;
	const vec2 in_uv = pixel_center/vec2(push.consts.width, push.consts.height);
	vec2 d = in_uv * 2.0 - 1.0; d.y *= -1.0;
    vec4 t = (projinv * vec4(d.x, d.y, 1, 1));
    vec3 target = t.xyz / t.w;
    vec3 origin = (viewinv * vec4(0,0,0,1)).xyz;
    vec3 direction = (viewinv * vec4(target, 0)).xyz ;
    direction = normalize(direction);
    
    /* We'll be computing direct and indirect path traced illumination for glossy and diffuse */
    vec3 diffuse_radiance = vec3(0.0);
    vec3 direct_diffuse_radiance = vec3(0.0);
    vec3 path_throughput = vec3(1.0);
    int bounce = 0;
    int transparency_continues = 0;
    do {
        /* Unpack Data */
        vec3 w_o = -direction;
        vec3 w_p = (bounce == 0) ? first_position : payload.w_p;
        vec2 uv = (bounce == 0) ? first_uv : payload.uv;
        vec3 w_x, w_y, w_z;
        w_z = (bounce == 0) ? first_normal : payload.w_n;
        bool backface = dot(w_z, w_o) < 0.0;
        float dist = (bounce == 0) ? first_dist : payload.distance;
        directionOfAnisotropicity(w_z, w_x, w_y);
        
        // Load required scene components
        EntityStruct entity; MaterialStruct mat; LightStruct light;
        int entity_id = (bounce == 0) ? first_entity_id : payload.entity_id;
        if ((entity_id >= 0) && (entity_id < max_entities)) entity = ebo.entities[entity_id];
        int material_id = (bounce == 0) ? first_material_id : entity.material_id;
        if ((material_id >= 0) && (material_id < max_materials)) mat = mbo.materials[material_id];
        if (bounce == 0) {
            mat.base_color = first_albedo;
        } else if (entity.initialized == 1) {
            mat.base_color = getAlbedo(mat, vec4(0.0), uv, w_p);
            float mask = getAlphaMask(mat, uv, w_p);
            mat.base_color.a = (mask < mat.base_color.a) ? mask : mat.base_color.a;
        }   
    
        /* If we hit the sky or a light, stop */
        if (entity_id == -1) { 
            /* todo, decide how to split this up into direct/indirect specular/diffuse, or neither */
            vec3 irradiance = (bounce == 0) ? first_albedo.rgb : get_environment_color(direction) * push.consts.environment_intensity;
            /* Include lighting from sky as direct lighting.  */
            break;
        }

        /* If the object we hit is completely transparent, go through it  */
        if ((mat.base_color.a < EPSILON) && (transparency_continues < MAX_TRANSPARENCY_CONTINUES)) {
            transparency_continues++;
            origin = payload.w_p + EPSILON * direction;
            continue;
        }

        /* Do next event estimation */
        float visibility = 1.0, l_dist;
        vec3 w_l, curr_diffuse_radiance, curr_specular_radiance;
        Irradiance irradiance = sample_direct_light_analytic(mat, backface, /* allow shadows */ true, 
            /*force_diffuse*/true, /*force_specular*/false, /*force_perfect_reflection*/false, 
            w_p, w_z, w_x, w_y, w_o);

        // If at bounce 0, we don't include diffuse color with diffuse. 
        // That will be multiplied later during compositing and after denoising
        if (bounce == 0) {
            vec3 specular = mix(vec3(1.0), mat.base_color.rgb, mat.metallic);
            curr_diffuse_radiance = irradiance.diffuse;
            curr_specular_radiance = irradiance.specular * specular;            
            diffuse_radiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
            direct_diffuse_radiance = diffuse_radiance;
        } else {
            vec3 diffuse = mat.base_color.rgb * (1.f - mat.metallic) * (1.f - mat.transmission);
            vec3 specular = mix(vec3(1.0), mat.base_color.rgb, mat.metallic);
            curr_diffuse_radiance = irradiance.diffuse * diffuse;
            curr_specular_radiance = irradiance.specular * specular;
            diffuse_radiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
        }
        
        /* Increase bounce count*/
        bounce++;
        if (bounce > max_path_depth) break;
        
        /* Setup next ray */
        vec3 w_i; float pdf, dpdf, spdf;
        vec3 bsdf, dbsdf, sbsdf;
        sample_disney_bsdf(mat, backface,
            w_z, w_o, w_x, w_y, 
            /*force_diffuse*/true, /*force_specular*/false, /*force_perfect_reflection*/false, 
            w_i, pdf, dpdf, spdf, bsdf, dbsdf, sbsdf);

        if (pdf < EPSILON || (all(lessThan(bsdf, vec3(EPSILON))))) break;

        /* For denoising purposes, we ignore path throughput for the first hit. */
        if (bounce > 1) path_throughput *= bsdf / pdf;

        /* Trace a ray through the scene */
        origin = offset_ray(w_p, w_z); direction = w_i;
        payload.is_shadow_ray = false;
        traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);
    } while (bounce <= max_path_depth);

    /* Write to G Buffers */
    vec3 indirect_diffuse_radiance = diffuse_radiance - direct_diffuse_radiance;
    
    // Direct Diffuse
    imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], tile, vec4(direct_diffuse_radiance, 1.0));

    // Indirect Diffuse
    imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], tile, vec4(indirect_diffuse_radiance, 1.0));

    // Luminance
    imageStore(gbuffers[LUMINANCE_ADDR], tile, vec4(luminance(direct_diffuse_radiance), 
                                                    luminance(indirect_diffuse_radiance), 
                                                    0.0,
                                                    0.0));
}

#version 460
#extension GL_NV_ray_tracing : require
#define GLOBAL_RAYTRACING

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/OffsetRay.hxx"

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * M_PI * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}

vec3 probeLocation(int index, vec3 bbmin, vec3 bbmax, ivec3 num_probes) {
    int x = index % num_probes.x;
    int remainder1 = index / num_probes.x;

    int y = remainder1 % num_probes.y;
    int remainder2 = remainder1 / num_probes.y;

    int z = remainder2 % num_probes.z;
    
    ivec3 probe_coords = ivec3(x,y,z); 
    vec3 norm_probe_coords = probe_coords / vec3(num_probes);
    return mix(bbmin, bbmax, norm_probe_coords);
}

void main() 
{
    int num_rays_per_probe = 64;
    ivec3 probeCount = ivec3(32, 32, 32);

    vec3 bbmin = vec3(push.consts.ph1, push.consts.ph2, push.consts.ph3);
    vec3 bbmax = vec3(push.consts.ph4, push.consts.ph5, push.consts.ph6);

    ivec2 gid = ivec2(gl_LaunchIDNV.xy);
    init_random(ivec2(gl_LaunchIDNV.xy), push.consts.frame, 0);

    int rayID = gid.x;
    int probeID = gid.y;

    // This value should be on the order of the normal bias.
    const float rayMinDistance = 0.08;

    mat4 random_rotation = rotationMatrix(normalize(vec3(random(), random(), random())), random() * 2.f * M_PI);
    vec3 origin = probeLocation(probeID, bbmin, bbmax, probeCount);
    vec3 direction = mat3(random_rotation) * sphericalFibonacci(rayID, num_rays_per_probe);

    // Trace the ray 
    // TODO: TAKE TRANSPARENCY INTO ACCOUNT?
    payload.is_shadow_ray = false;
    payload.entity_id = -1;
    traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);

    vec3 probe_irradiance = vec3(0.f);
    vec3 path_throughput = vec3(1.f); // Might need this later...
    float dist = INFINITY;

    vec3 w_p = direction * INFINITY;
    vec3 w_z = vec3(0.);

    /* If we hit the sky... */
    if (payload.entity_id < 0  || payload.entity_id >= MAX_ENTITIES) {
        probe_irradiance = get_environment_color(direction) * push.consts.environment_intensity;
    }
    else {        
        /* Unpack Data */
        vec3 w_o = -direction;
        w_p = payload.w_p;
        vec2 uv = payload.uv;
        vec3 w_x, w_y;
        w_z = payload.w_n;
        bool backface = dot(w_z, w_o) < 0.0;
        dist = payload.distance;

        // Load entity components
        EntityStruct entity; MaterialStruct mat; LightStruct light;
        int entity_id = payload.entity_id;
        if ((entity_id >= 0) && (entity_id < max_entities)) entity = ebo.entities[entity_id];
        int material_id = entity.material_id;
        if ((material_id >= 0) && (material_id < max_materials)) mat = mbo.materials[material_id];
        int light_id = entity.light_id;
        if (entity.initialized == 1) {
            mat.base_color = getAlbedo(mat, vec4(0.0), uv, w_p);
            float mask = getAlphaMask(mat, uv, w_p);
            mat.base_color.a = (mask < mat.base_color.a) ? mask : mat.base_color.a;
        }   

        /* Do next event estimation */
        float visibility = 1.0, l_dist;
        vec3 w_l, curr_diffuse_radiance, curr_specular_radiance;
        Irradiance irradiance;
        irradiance = sample_direct_light_analytic(mat, backface, /* allow shadows */ true, 
            /*force_diffuse*/true, /*force_specular*/false, /*force_perfect_reflection*/false, 
            w_p, w_z, w_x, w_y, w_o);

        // TODO: look up probe at hit position to retrieve GI

        // If at bounce 0, we don't include diffuse color with diffuse. 
        // Just computing irradiance for this probe.

        // FILTER OUT CAUSTICS HERE?
        vec3 diffuse = mat.base_color.rgb * (1.f - mat.metallic) * (1.f - mat.transmission);
        vec3 specular = vec3(0.0f);//mix(vec3(1.0), mat.base_color.rgb, mat.metallic);
        curr_diffuse_radiance = irradiance.diffuse * diffuse;
        curr_specular_radiance = irradiance.specular * specular;            
        probe_irradiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
        // direct_diffuse_radiance = diffuse_radiance;
    }

    imageStore(DDGI_GBUFFERS[0], gid, vec4(probe_irradiance, 1.0));
    imageStore(DDGI_GBUFFERS[1], gid, vec4(origin, 1.0));
    imageStore(DDGI_GBUFFERS[2], gid, vec4(direction, 1.0));
    imageStore(DDGI_GBUFFERS[3], gid, vec4(w_p, 1.0));
    imageStore(DDGI_GBUFFERS[4], gid, vec4(w_z, 1.0));

    // /* Next, Compute ray origin and direction */
    // init_random(ivec2(gl_LaunchIDNV.xy), push.consts.frame, 0);
    // int max_path_depth = int(push.consts.parameter1);
    // const ivec2 pixel_coords = ivec2(gl_LaunchIDNV.xy);

    // // vec4 temp = imageLoad(gbuffers[SEED_ADDR], pixel_coords);
    // // ivec2 pixel_seed = ivec2(temp.xy);
    // // int frame_seed = int(temp.z);
    // // init_random(pixel_seed, frame_seed, 0);
    
    // // float rand = random();
    // // imageStore(gbuffers[RANDOM_ADDR], pixel_coords, vec4(rand));

    // /* Next, Compute ray origin and direction */
    // EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    // CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    // TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    // int multiview_idx = 0; //push.consts.viewIndex;
    // mat4 projinv = camera.multiviews[multiview_idx].projinv;
    // mat4 viewinv = camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv;
    // vec2 pixel_center = vec2(pixel_coords.xy);// + vec2(random(), random()) * .5;
	// const vec2 in_uv = pixel_center/vec2(push.consts.width, push.consts.height);
	// vec2 d = in_uv * 2.0 - 1.0; d.y *= -1.0;
    // vec4 t = (projinv * vec4(d.x, d.y, 1, 1));
    // vec3 target = t.xyz / t.w;
    // vec3 origin = (viewinv * vec4(0,0,0,1)).xyz;
    // vec3 direction = (viewinv * vec4(target, 0)).xyz ;
    // direction = normalize(direction);

    // /* Trace a ray to compute primary visibility data */
    // vec3 world_position = vec3(INFINITY);
    // vec3 model_position = vec3(INFINITY);
    // vec3 world_normal = vec3(INFINITY);
    // vec3 albedo = vec3(0.0);
    // float metallic = 0.;
    // float roughness = 1.;
    // vec2 uv = vec2(0.0);
    // float dist = INFINITY;
    // int entity_id = -1;

    // int transparency_continues = 0;
    // int bounce = 0;
    // precise vec3 motion = vec3(0.0);
    // bool reset = true;
    // bool is_flat;
    // float curvature;

    // int mesh_id = -1; 
    // int tri_id = -1; 
    // vec2 barycentrics = vec2(0);

    // EntityStruct entity;
    // entity.initialized = 0;
    // entity.material_id = -1;
    // entity.transform_id = -1;
    // entity.light_id = -1;
    // MaterialStruct mat; LightStruct light;
    // do {
    //     bounce++;
    //     /* Trace a ray through the scene */
    //     payload.is_shadow_ray = false;
    //     payload.entity_id = -1;
    //     traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);

    //     /* If we hit the sky... */
    //     if (payload.entity_id < 0  || payload.entity_id >= MAX_ENTITIES) {
    //         albedo = get_environment_color(direction);
    //         break;
    //     }
        
    //     unpack_entity_struct(payload.entity_id, entity);
    //     unpack_material_struct(payload.entity_id, entity, payload.uv, payload.m_p, mat);
    //     unpack_light_struct(payload.entity_id, entity, light);

    //     /* If the object is completely transparent, go through it  */
    //     if ((mat.base_color.a < EPSILON) && (transparency_continues < MAX_TRANSPARENCY_CONTINUES)) {
    //         transparency_continues++;
    //         origin = payload.w_p + EPSILON * direction;
    //         continue;
    //     }

    //     mesh_id = payload.mesh;
    //     tri_id = payload.tri;
    //     barycentrics = payload.barycentrics;

    //     /* If the object is a light, use its light color as albedo */
    //     // Not sure why, but this causes albedo to be black?
    //     if ((entity.light_id >= 0) && (entity.light_id < max_lights)) 
    //     {
    //         // albedo += vec3(1.0, 1.0, 1.0);//light.color.rgb;// * light.intensity;
    //     }

    //     albedo = mat.base_color.rgb;
    //     metallic = mat.metallic;
    //     roughness = mat.roughness;
    //     entity_id = payload.entity_id;
    //     world_position = payload.w_p;
    //     model_position = payload.m_p;
    //     world_normal = payload.w_n;
    //     dist = payload.distance;
    //     uv = payload.uv;
    //     // is_flat = payload.is_flat;
    //     curvature = payload.curvature;

    //     /* Compute motion vector for primary visibility */
    //     if (entity.initialized == 1) {
    //         reset = false;
    //         TransformStruct transform = tbo.transforms[entity.transform_id];
    //         vec4 w_p_prev = transform.localToWorldPrev * vec4(model_position, 1.0);

    //         vec4 v_p_curr = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(world_position, 1.0);
    //         vec4 v_p_prev = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocalPrev * w_p_prev;

    //         motion = (v_p_prev.xyz / v_p_prev.w) - (v_p_curr.xyz / v_p_curr.w);
    //     }
        
    //     break;
    // } while (transparency_continues <= MAX_TRANSPARENCY_CONTINUES);

    // // specular lobe axis and sharpness 
    // vec3 w_i = normalize(reflect(direction, world_normal));
    // float alpha = clamp(roughness * roughness, .0000, 1.);
    // // important that this is between 0 and 1
    // float specular_sharpness = (1.0 - alpha); 
    

    // /* Write to G Buffers */
    // // ID data
    // imageStore(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(entity_id, entity.material_id, entity.transform_id, entity.light_id));

    // // Position G Buffer
    // imageStore(gbuffers[POSITION_DEPTH_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(world_position, dist));

    // // Normal G Buffer
    // imageStore(gbuffers[NORMAL_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(world_normal, curvature));//(is_flat) ? 1.f : 0.f));

    // // UV
    // imageStore(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(uv.x, uv.y, metallic, roughness));

    // // Diffuse color
    // imageStore(gbuffers[DIFFUSE_COLOR_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(albedo, 1.0));
    
    // // Glossy color
    // imageStore(gbuffers[GLOSSY_COLOR_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(1.0, 1.0, 1.0, 1.0));

    // // Motion Vector G Buffer
    // imageStore(gbuffers[DIFFUSE_MOTION_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(motion, (reset) ? 1.0 : 0.0));

    // // Specular lobe axis and sharpness
    // imageStore(gbuffers[LOBE_AXIS_SHARPNESS_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(w_i, specular_sharpness));

    // // Mesh ID, Tri ID, and Barycentrics
    // imageStore(gbuffers[ENTITY_TRI_BARYCENTRIC_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(barycentrics, entity_id, tri_id));

    

    // if (int(gl_LaunchIDNV.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
    // if (int(gl_LaunchIDNV.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;
    
    // Seed (For path tracing, downsampled)
    // imageStore(gbuffers[SEED_ADDR], ivec2(gl_LaunchIDNV.xy), vec4(pixel_seed, frame_seed, 1.0));
}
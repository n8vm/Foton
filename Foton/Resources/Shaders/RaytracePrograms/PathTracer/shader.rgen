#version 460
#extension GL_NV_ray_tracing : require
#define RAYTRACING

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/OffsetRay.hxx"
#include "Foton/Resources/Shaders/Common/LTCCommon.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"
#include "Foton/Resources/Shaders/Common/Lights.hxx"

vec3 Uncharted2Tonemap(vec3 x)
{
    x = max(x, vec3(0));
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E_ = 0.02;
	float F = 0.30;
	return max(vec3(0.0f), ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F))-E_/F);
}

void main() 
{
    if (int(gl_LaunchIDNV.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
    if (int(gl_LaunchIDNV.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;

    init_random(ivec2(gl_LaunchIDNV.xy), push.consts.frame, 0);
    float rand = random();
    
    int rand_curr = 0;//int(random(ivec2(gl_LaunchIDNV.xy), (push.consts.frame)) * PATH_TRACE_TILE_SIZE * PATH_TRACE_TILE_SIZE);
    ivec2 tile = ivec2(gl_LaunchIDNV.xy);
    ivec2 offset_curr = ivec2(rand_curr / PATH_TRACE_TILE_SIZE, rand_curr % PATH_TRACE_TILE_SIZE);

    /* These are required for shading purposes. Wait until they're ready. */
    if ((push.consts.ltc_mat_lut_id < 0) || (push.consts.ltc_mat_lut_id >= max_textures)) return;
    if ((push.consts.ltc_amp_lut_id < 0) || (push.consts.ltc_amp_lut_id >= max_textures)) return;
    
    /* Load primary visibility data from G Buffers */
    ivec2 pixel_coords;
    vec3 first_position, first_normal, albedo;
    float first_dist;
    int first_entity_id, frame_seed;
    ivec2 pixel_seed;
    vec2 first_uv;
    bool gradient_seed_found;
    unpack_gbuffer_data(tile, offset_curr, pixel_coords, gradient_seed_found, first_position, first_dist, first_normal, first_entity_id, 
        pixel_seed, frame_seed, albedo, first_uv);


    init_random(pixel_seed, frame_seed, 0);
    

    first_position += first_normal * .01; // bad precision in position g buffer... getting lots of self intersections...

    /* Next, Compute ray origin and direction */
    randomDimension = 0;
    int max_path_depth = int(push.consts.parameter1);
    vec3 origin, direction;
    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    int multiview_idx = push.consts.viewIndex;
    multiview_idx = 0; // temporary
    get_origin_and_direction(
        pixel_seed, frame_seed,
        camera.multiviews[multiview_idx].projinv,
        camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv,
        pixel_coords, ivec2(gl_LaunchSizeNV.xy), origin, direction);
    

    /* Compute direct and indirect path traced illumination */
    vec3 color = vec3(0.0);
    int bounce = 0;
    int transparency_continues = 0;
    bool last_event_was_specular = true;
    
    vec3 path_throughput = vec3(1.0);

    vec3 first_hit_path_throughput = vec3(1.0);
    int last_direct_light_entity_id = -2;

    vec3 direct_illumination = vec3(0.0);
    vec3 first_bsdf = vec3(0.0);

    vec3 w_s; // primary specular reflection dir
    vec3 w_p_s = first_position; // worldspace position of reflector
    vec3 w_p_i = vec3(0.);
    int reflected_entity_id = -1;
    vec3 specular_motion = vec3(0.0);

    vec3 incoming_path_throughput = vec3(1.0);
    vec3 glossy_path_throughput = vec3(1.0);
    vec3 incoming_illumination = vec3(0.0);
    vec3 glossy_illumination = vec3(0.0);

    do {
        /* Unpack Data */
        int entity_id = (bounce == 0) ? first_entity_id : payload.entity_id;
        vec3 w_o = -direction;
        vec3 w_p = (bounce == 0) ? first_position : payload.w_p;
        vec2 uv = (bounce == 0) ? first_uv : payload.uv;
        vec3 w_x, w_y, w_z;
        w_z = (bounce == 0) ? first_normal : payload.w_n;
        bool backface = dot(w_z, w_o) < 0.0;
        float dist = (bounce == 0) ? first_dist : payload.distance;
        if (bounce == 0) w_s = reflect(-w_o, w_x);
        directionOfAnisotropicity(w_z, w_x, w_y);

        EntityStruct entity; MaterialStruct mat; LightStruct light;
        unpack_entity_struct(entity_id, entity);
        unpack_material_struct(entity_id, entity, uv, w_p, mat); // to do, use primary albedo if bounce is 0
        unpack_light_struct(entity_id, entity, light);

        if (bounce == 0) mat.base_color.rgb = albedo;

        /* If we hit the sky or a light, stop */
        if (entity_id == -1) { 
            vec3 irradiance = (bounce == 0) ? albedo : get_environment_color(direction) * push.consts.environment_intensity;
            /* Include lighting from sky as direct lighting.  */
            if (bounce <= 1) {
                direct_illumination += path_throughput * irradiance;
            }
            incoming_illumination += incoming_path_throughput * irradiance;
            glossy_illumination += glossy_path_throughput * irradiance;
            color += path_throughput * irradiance;
            break;
        }

        /* If the object we hit is completely transparent, go through it  */
        if ((mat.base_color.a < EPSILON) && (transparency_continues < MAX_TRANSPARENCY_CONTINUES)) {
            transparency_continues++;
            origin = payload.w_p + EPSILON * direction;
            continue;
        }

        /* Don't double count light sources */
        if (entity_id == last_direct_light_entity_id) {
            break;
        }

        /* Reflected image worldspace position */
        if ((bounce == 1) && (entity_id != -1)) {
            // Compute previous reflector normals
            EntityStruct reflector_entity; TransformStruct reflector_transform;
            EntityStruct reflected_entity; TransformStruct reflected_transform;
            unpack_entity_struct(first_entity_id, reflector_entity);
            unpack_entity_struct(entity_id, reflected_entity);

            reflector_transform = tbo.transforms[reflector_entity.transform_id];
            reflected_transform = tbo.transforms[reflected_entity.transform_id];

            mat3 normLocalToWorld = transpose(mat3(reflector_transform.worldToLocal));
            mat3 normWorldToLocal = inverse(normLocalToWorld);
            mat3 normLocalToWorldPrev = transpose(mat3(reflector_transform.worldToLocalPrev));

            vec3 m_x_prev = normalize(normWorldToLocal * w_x);
            vec3 m_y_prev = normalize(normWorldToLocal * w_y);
            vec3 m_z_prev = normalize(normWorldToLocal * w_z);

            vec3 w_x_prev = normalize(normLocalToWorldPrev * m_x_prev);
            vec3 w_y_prev = normalize(normLocalToWorldPrev * m_y_prev);
            vec3 w_z_prev = normalize(normLocalToWorldPrev * m_z_prev);
            
            vec3 w_p_prev = vec3(reflector_transform.localToWorldPrev * reflector_transform.worldToLocal * vec4(w_p, 1.0));
            vec3 w_p_s_prev = vec3(reflected_transform.localToWorldPrev * reflected_transform.worldToLocal * vec4(w_p_s, 1.0));
            
            float x = dot(w_x, w_p_s - w_p);
            float y = dot(w_y, w_p_s - w_p);
            float z = dot(w_z, w_p_s - w_p);

            float x_prev = dot(w_x_prev, w_p_s_prev - w_p_prev);
            float y_prev = dot(w_y_prev, w_p_s_prev - w_p_prev);
            float z_prev = dot(w_z_prev, w_p_s_prev - w_p_prev);

            // position of reflected image in world space
            vec3 w_p_i = w_p + w_x * x + w_y * y + w_z * z;
            vec3 w_p_i_prev = w_p_prev + w_x_prev * x_prev + w_y_prev * y_prev + w_z_prev * z_prev;

            // float i_dist = distance(w_p_i_prev, w_p_prev);
            // float i_dist_prev = distance(w_p_i_prev, w_p_prev);

            // w_p_i = i_dist * (-w_o) + w_p;
            // w_p_i_prev = i_dist_prev * (-w_o) + w_p_prev;

            vec4 v_p_curr = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(w_p_i, 1.0);
            vec4 v_p_prev = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocalPrev * vec4(w_p_i_prev, 1.0);
            specular_motion = (v_p_prev.xyz / v_p_prev.w) - (v_p_curr.xyz / v_p_curr.w);

            
            reflected_entity_id = entity_id;
        }

        /* If we hit a light, radiate */
        if ((entity.light_id >= 0) && (entity.light_id < max_lights)) {
            // TEMPORARILY COMMENTING OUT WHILE WORKING ON LIGHTS
            /* Ignoring primary visibility hit, since it causes issues with temporal accumulation. 
            Instead, emitting primary visibility in remodulation */
            if (!is_ltc_enabled())
            {
                float attenuation = get_light_attenuation(light, payload.distance);
                if (bounce != 0) {
                    color += path_throughput * light.color.rgb * light.intensity * attenuation;
                        // direct_illumination = path_throughput * light.color.rgb * light.intensity;
                    incoming_illumination += incoming_path_throughput * light.color.rgb * light.intensity * attenuation;
                    glossy_illumination += glossy_path_throughput * light.color.rgb * light.intensity * attenuation;
                }
            }
            break;
        }

        /* Next event estimation */
        vec3 direct_diffuse_radiance;
        vec3 direct_specular_radiance;
        float visibility = 1.0;
        vec3 w_l;
        float l_dist;
        last_direct_light_entity_id = -1;
        if (/*(bounce == 0) && */(is_ltc_enabled())) {
            Radiance radiance = sample_direct_light_analytic(mat, backface, w_p, w_z, w_x, w_y, w_o);
            direct_diffuse_radiance = radiance.diffuse;
            direct_specular_radiance = radiance.specular;
        }
        else {
            // todo, separate diffuse from specular stochastic radiance
            vec3 stochastic_differential_direct_radiance = sample_direct_light_stochastic(mat, backface, w_p, w_z, w_x, w_y, w_o, last_direct_light_entity_id, visibility, w_l, l_dist);
            direct_diffuse_radiance = stochastic_differential_direct_radiance * visibility;
            direct_specular_radiance = vec3(0.0); 
        }
        
        if (bounce == 0) {
            color += path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
            incoming_illumination += incoming_path_throughput * (direct_diffuse_radiance);
            glossy_illumination += direct_specular_radiance;
        } 
        else 
        {
            color += path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
            incoming_illumination += incoming_path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
            glossy_illumination += glossy_path_throughput * (direct_diffuse_radiance) + direct_specular_radiance;
        }
        if (bounce == 0) 
        {
            direct_illumination = color;
        }

        /* Increase bounce count*/
        bounce++;

        /* Avoid sampling the brdf if this is the last path position */
        if (bounce > max_path_depth) break;

        /* Setup next ray */
        vec3 w_i; float pdf;
        float dpdf, spdf;
        vec3 bsdf, dbsdf, sbsdf;
        sample_disney_bsdf(mat, backface,
            w_z, w_o, w_x, w_y, w_i, pdf, dpdf, spdf, bsdf, dbsdf, sbsdf);
        if (bounce == 1) {
            first_bsdf = bsdf;
        }
        if (pdf < EPSILON || (all(lessThan(bsdf, vec3(EPSILON))))) {
            break;
        }



        path_throughput *= bsdf / max(pdf, PDF_CLAMP);

        /* for denoising, we factor out the diffuse and specular bsdfs for primary hits */
        if (bounce > 1) {
            if ((dpdf > EPSILON) && (all(greaterThan(dbsdf, vec3(EPSILON)))) && ((spdf > EPSILON) && (all(lessThan(sbsdf, vec3(EPSILON)))))) {
                incoming_path_throughput *= (dbsdf / max(dpdf, PDF_CLAMP));
            } else {
                incoming_path_throughput *= 0;
            }
            
            glossy_path_throughput *= bsdf / pdf;
        }
        else if (bounce == 1) {
            if ((spdf > EPSILON) && (all(greaterThan(sbsdf, vec3(EPSILON))))) {
                if ((spdf > EPSILON) && ((all(lessThan(sbsdf, vec3(EPSILON)))))) {
                    incoming_path_throughput *= (dbsdf / max(dpdf, PDF_CLAMP));
                } else {
                    incoming_path_throughput *= 0;
                }
                glossy_path_throughput *= sbsdf / max(spdf, PDF_CLAMP); 
            } else {
                glossy_path_throughput *= 0;
            }
        }

        // if (bounce == 1) {
        //     color += path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
        //     incoming_illumination += incoming_path_throughput * (direct_diffuse_radiance);
        //     glossy_illumination += glossy_path_throughput * (direct_diffuse_radiance) + direct_specular_radiance;
        // } 
        // else 
        // {
        //     color += path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
        //     incoming_illumination += incoming_path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
        //     glossy_illumination += glossy_path_throughput * (direct_diffuse_radiance) + direct_specular_radiance;
        // }
        // if (bounce == 1) 
        // {
        //     direct_illumination = color;
        // }

        if (all(lessThan(path_throughput, vec3(EPSILON)))) {
            break;
        }

        origin = offset_ray(w_p, w_z);
        direction = w_i;

        /* Trace a ray through the scene */
        payload.is_shadow_ray = false;
        traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);
    } while (bounce <= max_path_depth);

    /* Write to G Buffers */
    vec3 final_color = color;
    vec3 final_direct_illumination = direct_illumination;
    vec4 demodulation = vec4(1.0);//vec4(luminance(albedo) + vec3(EPSILON), luminance(albedo) + (EPSILON));

    // incoming_illumination = Uncharted2Tonemap(incoming_illumination.rgb * push.consts.exposure);
    // incoming_illumination = incoming_illumination * (1.0f / Uncharted2Tonemap(vec3(11.2f)));

    // glossy_illumination = Uncharted2Tonemap(glossy_illumination.rgb * push.consts.exposure);
    // glossy_illumination = glossy_illumination * (1.0f / Uncharted2Tonemap(vec3(11.2f)));

   

    for (int yy = 0; yy < PATH_TRACE_TILE_SIZE; yy++){
        for (int xx = 0; xx < PATH_TRACE_TILE_SIZE; xx++) {
            ivec2 p = tile * PATH_TRACE_TILE_SIZE + ivec2(xx,yy);
            
            // diffuse illumination
            vec3 final_incoming_illumination = incoming_illumination / demodulation.rgb;
            imageStore(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], p, vec4(final_incoming_illumination, 0));
           
            // glossy illumination
            vec3 final_glossy_illumination = glossy_illumination / demodulation.a;
            imageStore(gbuffers[SPECULAR_ILLUM_VAR_ADDR], p, vec4(final_glossy_illumination, 0));

            // Seed/luminance
            imageStore(gbuffers[SEED_LUMINANCE_ADDR], p, vec4(pixel_seed, frame_seed, luminance(incoming_illumination)));

            // Specular motion vector
            imageStore(gbuffers[SPECULAR_MOTION_ADDR], p, vec4(specular_motion, (reflected_entity_id == -1) ? 1.0 : 0.0));
        }
    }
    
}

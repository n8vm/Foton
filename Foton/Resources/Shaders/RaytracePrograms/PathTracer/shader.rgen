#version 460
#extension GL_NV_ray_tracing : require
#define RAYTRACING

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/OffsetRay.hxx"
#include "Foton/Resources/Shaders/Common/LTCCommon.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"
#include "Foton/Resources/Shaders/Common/Lights.hxx"

vec3 Uncharted2Tonemap(vec3 x)
{
    x = max(x, vec3(0));
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E_ = 0.02;
	float F = 0.30;
	return max(vec3(0.0f), ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F))-E_/F);
}

void main() 
{
    if (!validate()) return;

    init_random(ivec2(gl_LaunchIDNV.xy), push.consts.frame, 0);
    float rand = random();
    
    int rand_curr = 0;//int(random(ivec2(gl_LaunchIDNV.xy), (push.consts.frame)) * PATH_TRACE_TILE_SIZE * PATH_TRACE_TILE_SIZE);
    ivec2 tile = ivec2(gl_LaunchIDNV.xy);
    ivec2 offset_curr = ivec2(rand_curr / PATH_TRACE_TILE_SIZE, rand_curr % PATH_TRACE_TILE_SIZE);
    
    /* Load primary visibility data from G Buffers */
    ivec2 pixel_coords;
    vec3 first_position, first_normal, albedo;
    float first_dist;
    int first_entity_id, frame_seed;
    ivec2 pixel_seed;
    vec2 first_uv;
    bool gradient_seed_found;
    unpack_gbuffer_data(tile, offset_curr, pixel_coords, gradient_seed_found, first_position, first_dist, first_normal, first_entity_id, 
        pixel_seed, frame_seed, albedo, first_uv);


    init_random(pixel_seed, frame_seed, 0);
    
    first_position += first_normal * .01; // bad precision in position g buffer... getting lots of self intersections...

    /* Next, Compute ray origin and direction */
    randomDimension = 0;
    int max_path_depth = int(push.consts.parameter1);
    vec3 origin, direction;
    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    int multiview_idx = push.consts.viewIndex;
    multiview_idx = 0; // temporary
    get_origin_and_direction(
        pixel_seed, frame_seed,
        camera.multiviews[multiview_idx].projinv,
        camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv,
        pixel_coords, ivec2(gl_LaunchSizeNV.xy), origin, direction);
    
    /* Compute direct and indirect path traced illumination */
    vec3 combined_radiance = vec3(0.0);
    int bounce = 0;
    int transparency_continues = 0;
    bool last_event_was_specular = true;
    
    vec3 path_throughput = vec3(1.0);

    vec3 first_hit_path_throughput = vec3(1.0);
    int last_direct_light_entity_id = -2;

    vec3 direct_illumination = vec3(0.0);
    vec3 first_bsdf = vec3(0.0);

    vec3 w_s; // primary specular reflection dir
    vec3 w_p_s = first_position; // worldspace position of reflector
    vec3 w_n_s = first_normal;
    vec3 w_p_i = vec3(0.); // worldspace position of image in reflection
    vec3 first_direction = direction;
    vec3 w_p_r = reflect(first_direction, first_normal) * 100000.0; // worldspace position of object being reflected
    int reflected_entity_id = -1;
    vec3 specular_motion = vec3(0.0);

    vec3 indirect_diffuse_path_throughput = vec3(1.0);
    vec3 glossy_path_throughput = vec3(1.0);
    vec3 incoming_illumination = vec3(0.0);
    vec3 glossy_illumination = vec3(0.0);


    // vec3 indirect_diffuse_path_throughput = vec3(1.0);

    vec3 diffuse_radiance = vec3(0.0);
    vec3 specular_radiance = vec3(0.0);
    vec3 direct_diffuse_radiance = vec3(0.0);
    vec3 direct_specular_radiance = vec3(0.0);

    vec3 first_refl_dir = vec3(0.f);
    float first_lobe_sharpness = 0.f;

    do {
        /* Unpack Data */
        int entity_id = (bounce == 0) ? first_entity_id : payload.entity_id;
        vec3 w_o = -direction;
        vec3 w_p = (bounce == 0) ? first_position : payload.w_p;
        vec2 uv = (bounce == 0) ? first_uv : payload.uv;
        vec3 w_x, w_y, w_z;
        w_z = (bounce == 0) ? first_normal : payload.w_n;
        bool backface = dot(w_z, w_o) < 0.0;
        float dist = (bounce == 0) ? first_dist : payload.distance;
        if (bounce == 0) w_s = reflect(-w_o, w_x);
        directionOfAnisotropicity(w_z, w_x, w_y);

        EntityStruct entity; MaterialStruct mat; LightStruct light;
        unpack_entity_struct(entity_id, entity);
        unpack_material_struct(entity_id, entity, uv, w_p, mat); // to do, use primary albedo if bounce is 0
        unpack_light_struct(entity_id, entity, light);
        if (bounce == 0) mat.base_color.rgb = albedo;

        /* If we hit the sky or a light, stop */
        if (entity_id == -1) { 
            /* todo, decide how to split this up into direct/indirect specular/diffuse, or neither */
            vec3 irradiance = (bounce == 0) ? albedo : get_environment_color(direction) * push.consts.environment_intensity;
            /* Include lighting from sky as direct lighting.  */
            if (bounce <= 1) {
                direct_illumination += path_throughput * irradiance;
            }
            incoming_illumination += indirect_diffuse_path_throughput * irradiance;
            glossy_illumination += glossy_path_throughput * irradiance;
            combined_radiance += path_throughput * irradiance;
            break;
        }

        /* If the object we hit is completely transparent, go through it  */
        if ((mat.base_color.a < EPSILON) && (transparency_continues < MAX_TRANSPARENCY_CONTINUES)) {
            transparency_continues++;
            origin = payload.w_p + EPSILON * direction;
            continue;
        }

        /* Reflected image worldspace position */
        if ((bounce == 1) && (entity_id != -1)) {
            w_p_r = w_p;
            reflected_entity_id = entity_id;            
        }

        /* Don't double count light sources */
        /* TODO: this doesn't work when sampling from multiple light sources simultaneously... */
        if (entity_id == last_direct_light_entity_id) {
            break;
        }       

        /* If we hit a light, radiate */
        if ((entity.light_id >= 0) && (entity.light_id < max_lights)) {
            // TEMPORARILY COMMENTING OUT WHILE WORKING ON LIGHTS
            /* Ignoring primary visibility hit, since it causes issues with temporal accumulation. 
            Instead, emitting primary visibility in remodulation */
            if (!is_ltc_enabled())
            {
                float attenuation = get_light_attenuation(light, payload.distance);
                if (bounce != 0) {
                    combined_radiance += path_throughput * light.color.rgb * light.intensity * attenuation;
                        // direct_illumination = path_throughput * light.color.rgb * light.intensity;
                    incoming_illumination += indirect_diffuse_path_throughput * light.color.rgb * light.intensity * attenuation;
                    glossy_illumination += glossy_path_throughput * light.color.rgb * light.intensity * attenuation;
                }
            }
            break;
        }

        /* Next event estimation */
        float visibility = 1.0;
        vec3 w_l;
        float l_dist;
        vec3 curr_diffuse_radiance;
        vec3 curr_specular_radiance;
        last_direct_light_entity_id = -1;
        if (is_ltc_enabled()) {
            Irradiance irradiance = sample_direct_light_analytic(mat, backface, true, w_p, w_z, w_x, w_y, w_o);
            // If at bounce 0, we don't include diffuse color with diffuse. 
            // That will be multiplied later during compositing and after denoising
            if (bounce == 0 ){
                vec3 specular = mix(vec3(1.0), mat.base_color.rgb, mat.metallic);
                curr_diffuse_radiance = irradiance.diffuse;
                curr_specular_radiance = irradiance.specular * specular;
            } else {
                vec3 diffuse = mat.base_color.rgb * (1.f - mat.metallic) * (1.f - mat.transmission);
                vec3 specular = mix(vec3(1.0), mat.base_color.rgb, mat.metallic);
                curr_diffuse_radiance = irradiance.diffuse * diffuse;
                curr_specular_radiance = irradiance.specular * specular;
            }
        }
        else {
            // todo, separate diffuse from specular stochastic radiance
            vec3 stochastic_differential_direct_radiance = sample_direct_light_stochastic(mat, backface, w_p, w_z, w_x, w_y, w_o, last_direct_light_entity_id, visibility, w_l, l_dist);
            curr_diffuse_radiance = stochastic_differential_direct_radiance * visibility;
            curr_specular_radiance = vec3(0.0); 
        }

        
        combined_radiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);

        if (bounce == 0) {
            diffuse_radiance += indirect_diffuse_path_throughput * curr_diffuse_radiance;
            specular_radiance += path_throughput * curr_specular_radiance;
            direct_diffuse_radiance = diffuse_radiance;
            direct_specular_radiance = specular_radiance;



            incoming_illumination += indirect_diffuse_path_throughput * (curr_diffuse_radiance);
            glossy_illumination += curr_specular_radiance;
            direct_illumination = combined_radiance;
        } 
        else 
        {
            diffuse_radiance += indirect_diffuse_path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
            specular_radiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);

            

            combined_radiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
            incoming_illumination += indirect_diffuse_path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
            glossy_illumination += glossy_path_throughput * (curr_diffuse_radiance) + curr_specular_radiance;
        }


        /* Increase bounce count*/
        bounce++;
        
        /* Avoid sampling the brdf if this is the last path position */
        if (bounce > max_path_depth) break;

        /* Setup next ray */
        vec3 w_i; float pdf;
        float dpdf, spdf;
        vec3 bsdf, dbsdf, sbsdf;
        sample_disney_bsdf(mat, backface,
            w_z, w_o, w_x, w_y, 
            false, false, false, // TEMPORARILY FORCING SPECULAR
            w_i, pdf, dpdf, spdf, bsdf, dbsdf, sbsdf);
        if (bounce == 1) {
            first_bsdf = bsdf;
        }
        if (pdf < EPSILON || (all(lessThan(bsdf, vec3(EPSILON))))) {
            break;
        }

        path_throughput *= bsdf / max(pdf, PDF_CLAMP);

        /* for denoising, we factor out the diffuse and specular bsdfs for primary hits */
        if (bounce > 1) {
            if ((dpdf > EPSILON) && (all(greaterThan(dbsdf, vec3(EPSILON)))) && ((spdf > EPSILON) && (all(lessThan(sbsdf, vec3(EPSILON)))))) {
                indirect_diffuse_path_throughput *= (dbsdf / max(dpdf, PDF_CLAMP));
            } else {
                indirect_diffuse_path_throughput *= 0;
            }
            
            glossy_path_throughput *= bsdf / pdf;
        }
        else if (bounce == 1) {
            if ((spdf > EPSILON) && (all(greaterThan(sbsdf, vec3(EPSILON))))) {
                if ((spdf > EPSILON) && ((all(lessThan(sbsdf, vec3(EPSILON)))))) {
                    indirect_diffuse_path_throughput *= (dbsdf / max(dpdf, PDF_CLAMP));
                } else {
                    indirect_diffuse_path_throughput *= 0;
                }
                glossy_path_throughput *= sbsdf / max(spdf, PDF_CLAMP); 
            } else {
                glossy_path_throughput *= 0;
            }
        }

        // if (bounce == 1) {
        //     color += path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
        //     incoming_illumination += indirect_diffuse_path_throughput * (direct_diffuse_radiance);
        //     glossy_illumination += glossy_path_throughput * (direct_diffuse_radiance) + direct_specular_radiance;
        // } 
        // else 
        // {
        //     color += path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
        //     incoming_illumination += indirect_diffuse_path_throughput * (direct_diffuse_radiance + direct_specular_radiance);
        //     glossy_illumination += glossy_path_throughput * (direct_diffuse_radiance) + direct_specular_radiance;
        // }
        // if (bounce == 1) 
        // {
        //     direct_illumination = color;
        // }

        if (all(lessThan(path_throughput, vec3(EPSILON)))) {
            break;
        }

        origin = offset_ray(w_p, w_z);
        direction = w_i;

        /* Trace a ray through the scene */
        payload.is_shadow_ray = false;
        traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);
    } while (bounce <= max_path_depth);

    /* Compute specular motion vector */
    {
        // Compute previous reflector normals
        EntityStruct reflector_entity; TransformStruct reflector_transform;
        EntityStruct reflected_entity; TransformStruct reflected_transform;
        unpack_entity_struct(first_entity_id, reflector_entity);
        unpack_entity_struct(reflected_entity_id, reflected_entity);

        reflector_transform = tbo.transforms[reflector_entity.transform_id];
        if (reflected_entity.initialized == 1) {
            reflected_transform = tbo.transforms[reflected_entity.transform_id];
        }

        // Create basis around reflector normal
        vec3 w_x_s, w_y_s;
        directionOfAnisotropicity(w_n_s, w_x_s, w_y_s);

        mat3 normLocalToWorld = transpose(mat3(reflector_transform.worldToLocal));
        mat3 normWorldToLocal = inverse(normLocalToWorld);
        mat3 normLocalToWorldPrev = transpose(mat3(reflector_transform.worldToLocalPrev));

        vec3 m_x_s_prev = normalize(normWorldToLocal * w_x_s);
        vec3 m_y_s_prev = normalize(normWorldToLocal * w_y_s);
        vec3 m_n_s_prev = normalize(normWorldToLocal * w_n_s);

        vec3 w_x_s_prev = normalize(normLocalToWorldPrev * m_x_s_prev);
        vec3 w_y_s_prev = normalize(normLocalToWorldPrev * m_y_s_prev);
        vec3 w_n_s_prev = normalize(normLocalToWorldPrev * m_n_s_prev);
        
        // Compute previous reflector position
        vec3 w_p_s_prev = vec3(reflector_transform.localToWorldPrev * reflector_transform.worldToLocal * vec4(w_p_s, 1.0));
        
        // Compute previous reflected position (if sky, previous is the same as current)
        vec3 w_p_r_prev = w_p_r;
        if (reflected_entity.initialized == 1) {
            w_p_r_prev = vec3(reflected_transform.localToWorldPrev * reflected_transform.worldToLocal * vec4(w_p_r, 1.0));
        }
        
        // Thin film approximation
        float x = dot(w_x_s, w_p_r - w_p_s);
        float y = dot(w_y_s, w_p_r - w_p_s);
        float z = dot(w_n_s, w_p_r - w_p_s);

        float x_prev = dot(w_x_s_prev, w_p_r_prev - w_p_s_prev);
        float y_prev = dot(w_y_s_prev, w_p_r_prev - w_p_s_prev);
        float z_prev = dot(w_n_s_prev, w_p_r_prev - w_p_s_prev);

        // position of reflected image in world space
        vec3 w_p_i = w_p_s + w_x_s * x + w_y_s * y + w_n_s * z;
        vec3 w_p_i_prev = w_p_s_prev + w_x_s_prev * x_prev + w_y_s_prev * y_prev + w_n_s_prev * z_prev;

        // float i_dist = distance(w_p_i, w_p_s);
        // float i_dist_prev = distance(w_p_i_prev, w_p_s_prev);

        // w_p_i = i_dist * (first_direction) + w_p_s;
        // w_p_i_prev = i_dist_prev * (first_direction) + w_p_s_prev;

        vec4 v_p_curr = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(w_p_i, 1.0);
        vec4 v_p_prev = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocalPrev * vec4(w_p_i_prev, 1.0);
        specular_motion = (v_p_prev.xyz / v_p_prev.w) - (v_p_curr.xyz / v_p_curr.w);
    }

    if (reflected_entity_id == -1) specular_motion = vec3(0);

    /* Write to G Buffers */
    vec3 final_color = combined_radiance;
    vec3 final_direct_illumination = direct_illumination;
    vec4 demodulation = vec4(1.0);//vec4(luminance(albedo) + vec3(EPSILON), luminance(albedo) + (EPSILON));

    // incoming_illumination = Uncharted2Tonemap(incoming_illumination.rgb * push.consts.exposure);
    // incoming_illumination = incoming_illumination * (1.0f / Uncharted2Tonemap(vec3(11.2f)));

    // glossy_illumination = Uncharted2Tonemap(glossy_illumination.rgb * push.consts.exposure);
    // glossy_illumination = glossy_illumination * (1.0f / Uncharted2Tonemap(vec3(11.2f)));

   vec3 indirect_diffuse_radiance = diffuse_radiance - direct_diffuse_radiance;
   vec3 indirect_specular_radiance = specular_radiance - direct_specular_radiance;

    for (int yy = 0; yy < PATH_TRACE_TILE_SIZE; yy++){
        for (int xx = 0; xx < PATH_TRACE_TILE_SIZE; xx++) {
            ivec2 p = tile * PATH_TRACE_TILE_SIZE + ivec2(xx,yy);

            // Seed/luminance
            imageStore(gbuffers[SEED_LUMINANCE_ADDR], p, vec4(pixel_seed, frame_seed, luminance(incoming_illumination)));

            // Specular motion vector
            imageStore(gbuffers[GLOSSY_MOTION_ADDR], p, vec4(specular_motion, (first_entity_id == -1) ? 1.0 : 0.0));
            
            // Diffuse illumination (might remove...)
            // imageStore(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], p, vec4(incoming_illumination, 0));

            // Glossy illumination (might remove...)
            // imageStore(gbuffers[GLOSSY_ILLUM_VAR_ADDR], p, vec4(glossy_illumination, 0));



            // Direct Diffuse
            imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], p, vec4(direct_diffuse_radiance, 1.0));

            // Indirect Diffuse
            imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], p, vec4(indirect_diffuse_radiance, 1.0));

            // Direct Glossy
            imageStore(gbuffers[GLOSSY_DIRECT_ADDR], p, vec4(direct_specular_radiance, 1.0));

            // Indirect Glossy 
            imageStore(gbuffers[GLOSSY_INDIRECT_ADDR], p, vec4(indirect_specular_radiance, 1.0));

            // Luminance
            imageStore(gbuffers[LUMINANCE_ADDR], p, vec4(luminance(direct_diffuse_radiance), 
                                                         luminance(indirect_diffuse_radiance), 
                                                         luminance(direct_specular_radiance),
                                                         luminance(indirect_specular_radiance)));
        }
    }
    
}

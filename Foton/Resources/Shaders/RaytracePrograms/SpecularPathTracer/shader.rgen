#version 460
#extension GL_NV_ray_tracing : require
#define CAMERA_RAYTRACING

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/OffsetRay.hxx"
#include "Foton/Resources/Shaders/Common/LTCCommon.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"
#include "Foton/Resources/Shaders/Common/Lights.hxx"

vec3 Uncharted2Tonemap(vec3 x)
{
    x = max(x, vec3(0));
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E_ = 0.02;
	float F = 0.30;
	return max(vec3(0.0f), ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F))-E_/F);
}

void get_mesh_data(int mesh_id, int prim_id, vec2 bary, out vec4 P, out vec3 N, out vec2 UV, out float curvature) {
    vec3 barycentrics = vec3(1.0f - bary.x - bary.y, bary.x, bary.y);
    
    ivec3 indices;
    indices.x = IndexBuffers[mesh_id].indices[3 * prim_id + 0];
	indices.y = IndexBuffers[mesh_id].indices[3 * prim_id + 1];
	indices.z = IndexBuffers[mesh_id].indices[3 * prim_id + 2];

    vec4 P0 = PositionBuffers[mesh_id].positions[indices.x];
	vec4 P1 = PositionBuffers[mesh_id].positions[indices.y];
	vec4 P2 = PositionBuffers[mesh_id].positions[indices.z];
	P = P0 * barycentrics.x + P1 * barycentrics.y + P2 * barycentrics.z;
    
    vec3 N0 = NormalBuffers[mesh_id].normals[indices.x].xyz;
	vec3 N1 = NormalBuffers[mesh_id].normals[indices.y].xyz;
	vec3 N2 = NormalBuffers[mesh_id].normals[indices.z].xyz;
	N = N0 * barycentrics.x + N1 * barycentrics.y + N2 * barycentrics.z;
    
    vec2 UV0 = TexCoordBuffers[mesh_id].texcoords[indices.x].xy;
	vec2 UV1 = TexCoordBuffers[mesh_id].texcoords[indices.y].xy;
	vec2 UV2 = TexCoordBuffers[mesh_id].texcoords[indices.z].xy;
	UV = UV0 * barycentrics.x + UV1 * barycentrics.y + UV2 * barycentrics.z;

    float edge_curvature_1 = abs(dot((N2-N1), (P2.xyz-P1.xyz))/(distance(P2.xyz,P1.xyz)*distance(P2.xyz,P1.xyz)));
	float edge_curvature_2 = abs(dot((N1-N0), (P1.xyz-P0.xyz))/(distance(P1.xyz,P0.xyz)*distance(P1.xyz,P0.xyz)));
	float edge_curvature_3 = abs(dot((N0-N2), (P0.xyz-P2.xyz))/(distance(P0.xyz,P2.xyz)*distance(P0.xyz,P2.xyz)));

	float v_c_1 = (edge_curvature_2 + edge_curvature_3) * .5;
	float v_c_2 = (edge_curvature_1 + edge_curvature_2) * .5;
	float v_c_3 = (edge_curvature_1 + edge_curvature_3) * .5;
	curvature = barycentrics.x * v_c_1 + barycentrics.y * v_c_2 + barycentrics.z * v_c_3;
}

// 12.3 ms, VRAM 56.8%, L2 28.1%, TEX 13.2%
void main() 
{
    if (int(gl_LaunchIDNV.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
    if (int(gl_LaunchIDNV.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;

    ivec2 tile = ivec2(gl_LaunchIDNV.xy);
    ivec2 ipos_full = tile * PATH_TRACE_TILE_SIZE;
    init_random(ivec2(gl_LaunchIDNV.xy), push.consts.frame, 0);

    // Compute random offset within gradient tile
    int grad_rand = push.consts.frame % (GRADIENT_TILE_SIZE * GRADIENT_TILE_SIZE);
    ivec2 grad_offset = ivec2(grad_rand / GRADIENT_TILE_SIZE, grad_rand % GRADIENT_TILE_SIZE);
    ivec2 grad_tile = ivec2(gl_LaunchIDNV.xy / GRADIENT_TILE_SIZE);
    ivec2 grad_pt_tile = GRADIENT_TILE_SIZE * grad_tile + grad_offset;

    // Compute motion vector
    ivec2 ipos_tile_prev, ipos_full_prev;
    bool reproj_on_screen = true;
    // {
    //     precise vec4 motion_data = vec4(0);//imageLoad(gbuffers[SPECULAR_MOTION_ADDR], tile);
    //     precise vec2 v = motion_data.xy * vec2(.5, -.5);
    //     precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height) / PATH_TRACE_TILE_SIZE;
    //     ipos_tile_prev = ivec2(tile + iv + MOTION_VECTOR_OFFSET);
    //     ipos_full_prev = ipos_tile_prev * PATH_TRACE_TILE_SIZE;
    //     bvec2 a = greaterThan(ipos_full_prev, vec2(push.consts.width-1, push.consts.height-1));
    //     bvec2 b = lessThan(ipos_full_prev, vec2(0.0, 0.0));
    //     reproj_on_screen = reproj_on_screen && (!any(bvec2(any(a), any(b))));
    // }

    {
        precise vec4 motion_data = imageLoad(gbuffers[SPECULAR_MOTION_ADDR], tile);
        imageStore(gbuffers[SPECULAR_MOTION_ADDR_PREV], tile, motion_data);
        precise vec2 v = motion_data.xy * vec2(.5, -.5);
        precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
        ipos_tile_prev = ivec2(ipos_full + (iv + MOTION_VECTOR_OFFSET)) / PATH_TRACE_TILE_SIZE;
        ipos_full_prev = ipos_tile_prev * PATH_TRACE_TILE_SIZE;
        bvec2 a = greaterThan(ipos_full_prev, vec2(push.consts.width-1, push.consts.height-1));
        bvec2 b = lessThan(ipos_full_prev, vec2(0.0, 0.0));
        reproj_on_screen = reproj_on_screen && (!any(bvec2(any(a), any(b))));
    }

    /* Load primary visibility data from G Buffers */
    vec4 temp; int addr;
    bool seed_reprojected = reproj_on_screen && all(equal(grad_pt_tile, tile)) && is_gradient_estimation_enabled();;
    ivec2 gbuf_pos = (seed_reprojected) ? ipos_tile_prev : tile;

    // Seed G Buffer
    addr = (seed_reprojected) ? SPECULAR_SEED_ADDR_PREV : SPECULAR_SEED_ADDR;
    temp = imageLoad(gbuffers[addr], gbuf_pos);
    ivec2 pixel_seed = ivec2(temp.xy);
    int frame_seed = int(temp.z);
    init_random(pixel_seed, frame_seed, 0);

    // Barycentrics G Buffer
    gbuf_pos = (seed_reprojected) ? ipos_tile_prev : ipos_full;
    addr = (seed_reprojected) ? COARSE_SPECULAR_ENTITY_TRI_BARYCENTRIC_ADDR_PREV : ENTITY_TRI_BARYCENTRIC_ADDR;
    temp = imageLoad(gbuffers[addr], gbuf_pos);
    int first_bary_entity_id = int(temp.b), first_tri_id = int(temp.a);
    vec2 first_barycentrics = vec2(temp.rg);
    bool mesh_valid = ((first_bary_entity_id >= 0) && (first_tri_id >= 0));

    vec4 first_bary_normal;
    vec2 first_bary_uv;
    vec4 first_bary_position;
    vec4 first_bary_base_color;
    int first_bary_material_id, first_bary_transform_id, first_bary_light_id, first_bary_mesh_id;
    if (seed_reprojected && mesh_valid) 
    {
        TransformStruct first_transform_struct;
        EntityStruct entity = ebo.entities[first_bary_entity_id];
        first_bary_mesh_id = entity.mesh_id;
        first_bary_material_id = entity.material_id;
        first_bary_transform_id = entity.transform_id;
        first_bary_light_id = entity.light_id;
        first_transform_struct = tbo.transforms[entity.transform_id];   
        vec4 P; vec3 N; vec2 UV; float curvature;
        get_mesh_data(first_bary_mesh_id, first_tri_id, first_barycentrics, P, N, UV, curvature);
        first_bary_uv = UV;
        first_bary_position = first_transform_struct.localToWorld * vec4(P.xyz, 1.0);
        first_bary_normal = vec4(normalize(transpose(mat3(first_transform_struct.worldToLocal)) * N), curvature);
        MaterialStruct mat = mbo.materials[first_bary_material_id];
        first_bary_base_color = getAlbedo(mat, vec4(0.0), first_bary_uv, first_bary_position.xyz);
        float mask = getAlphaMask(mat, first_bary_uv, first_bary_position.xyz);
        first_bary_base_color.a = (mask < first_bary_base_color.a) ? mask : first_bary_base_color.a;
    }

    // Position G Buffer   
    if (seed_reprojected) temp = vec4(first_bary_position.xyz, 0);
    else temp = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos_full);
    vec3 first_position = temp.xyz;
    vec3 first_position_ = temp.xyz;
    float first_dist = 0;//temp.w;

    // Normal G Buffer
    if (seed_reprojected) temp = first_bary_normal;
    else temp = imageLoad(gbuffers[NORMAL_ADDR], ipos_full);
    vec3 first_normal = normalize(temp.xyz);
    float reflector_curvature = temp.w;
    bool reflector_is_flat = (temp.w < .01);

    // Component IDs
    if (seed_reprojected) temp = vec4(first_bary_entity_id, first_bary_material_id, first_bary_transform_id, first_bary_light_id);
    else temp = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full);
    int first_entity_id = int(temp.r);
    int first_material_id = int(temp.g);
    int first_transform_id = int(temp.b);
    int first_light_id = int(temp.a);

    // UV G Buffer
    if (seed_reprojected) temp = vec4(first_bary_uv.xy, 0, 0);
    else temp = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ipos_full);
    vec2 first_uv = temp.xy;

    // Raw albedo
    if (seed_reprojected) temp = vec4(first_bary_base_color.rgb, 1.0);
    else temp = imageLoad(gbuffers[DIFFUSE_COLOR_ADDR], ipos_full);
    vec4 first_albedo = temp;
    
    /* Next, Compute ray origin and direction */
    // TESTING: Note for specular, the camera shouldn't cause a temporal gradient,
    // 
    int max_path_depth = int(push.consts.parameter1);
    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    int multiview_idx = 0; //push.consts.viewIndex;
    mat4 projinv = camera.multiviews[multiview_idx].projinv;
    mat4 viewinv = (camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv);
    vec2 pixel_center = vec2(ipos_full.xy) + vec2(random(), random()) * .5;
    // mat4 viewinv = (seed_reprojected) ? (camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv) 
    //                                   : (camera_transform.localToWorldPrev * camera.multiviews[multiview_idx].viewinv);
    // vec2 pixel_center = vec2(pixel_seed * PATH_TRACE_TILE_SIZE) + vec2(random(), random()) * .5;
	const vec2 in_uv = pixel_center/vec2(push.consts.width, push.consts.height);
	vec2 d = in_uv * 2.0 - 1.0; d.y *= -1.0;
    vec4 t = (projinv * vec4(d.x, d.y, 1, 1));
    vec3 target = t.xyz / t.w;
    vec3 origin = (viewinv * vec4(0,0,0,1)).xyz;
    vec3 direction = (viewinv * vec4(target, 0)).xyz ;
    direction = normalize(direction);

    if (seed_reprojected) {
        ivec2 gbuf_pos = (seed_reprojected) ? ipos_tile_prev : tile;
        direction = imageLoad(gbuffers[COARSE_SPECULAR_CAMERA_DIRECTION_ADDR_PREV], gbuf_pos).xyz;
    }

    vec3 first_direction = direction;

    // Make normal forward facing
    if (dot(direction, first_normal) > 0) first_normal *= -1;

    // bad precision in position g buffer... getting lots of self intersections...
    first_position += first_normal * .01; 
    
    /* We'll be computing direct and indirect path traced illumination for glossy and diffuse */
    vec3 specular_radiance = vec3(0.0);
    vec3 direct_specular_radiance = vec3(0.0);
    vec3 path_throughput = vec3(1.0);

    /* We'll also be computing a specular image motion vector */
    vec3 w_s; // primary specular reflection dir
    vec3 w_p_s = first_position; // worldspace position of reflector
    vec3 w_n_s = normalize(first_normal);
    vec3 w_p_i = vec3(0.); // worldspace position of image in reflection
    vec3 w_p_r = reflect(direction, first_normal) * 100000.0; // worldspace position of object being reflected
    vec3 specular_motion = vec3(0.0);
    int reflected_entity_id = -1;

    int last_direct_light_entity_id = -2;
    int bounce = 0;
    int transparency_continues = 0;
    
    float max_roughness = 0;
    do {
        /* Unpack Data */
        vec3 w_o = -direction;
        vec3 w_p = (bounce == 0) ? first_position : payload.w_p;
        vec2 uv = (bounce == 0) ? first_uv : payload.uv;
        vec3 w_x, w_y, w_z;
        w_z = (bounce == 0) ? first_normal : payload.w_n;
        bool backface = dot(w_z, w_o) < 0.0;
        float dist = (bounce == 0) ? first_dist : payload.distance;
        if (bounce == 0) w_s = reflect(-w_o, w_x);
        directionOfAnisotropicity(w_z, w_x, w_y);

        // Load required scene components
        EntityStruct entity; MaterialStruct mat; LightStruct light;
        int entity_id = (bounce == 0) ? first_entity_id : payload.entity_id;
        if ((entity_id >= 0) && (entity_id < max_entities)) entity = ebo.entities[entity_id];
        int material_id = (bounce == 0) ? first_material_id : entity.material_id;
        if ((material_id >= 0) && (material_id < max_materials)) mat = mbo.materials[material_id];
        int light_id = (bounce == 0) ? first_light_id : entity.light_id;
        if (bounce == 0) {
            mat.base_color = first_albedo;
        } else if (entity.initialized == 1) {
            mat.base_color = getAlbedo(mat, vec4(0.0), uv, w_p);
            float mask = getAlphaMask(mat, uv, w_p);
            mat.base_color.a = (mask < mat.base_color.a) ? mask : mat.base_color.a;
        }   

        max_roughness = max(mat.roughness, max_roughness);

        /* If we hit the sky or a light, stop */
        if ((entity_id == -1) || light_id != -1) { 
            /* Include lighting from sky as indirect lighting.  */
            if (bounce > 0) {
                vec3 irradiance;
                if (entity_id == -1) {
                    irradiance = get_environment_color(direction) * push.consts.environment_intensity;
                } else {
                    LightStruct light = lbo.lights[entity.light_id];
                    // Reduce fireflies by only accounting for direct lights when no hit was diffuse
                    irradiance = mix(light.color.rgb * light.intensity, vec3(0.0), max_roughness);
                }
                specular_radiance += path_throughput * (irradiance);
            }
            break;
        }

        /* If the object we hit is completely transparent, go through it  */
        if ((mat.base_color.a < EPSILON) && (transparency_continues < MAX_TRANSPARENCY_CONTINUES)) {
            transparency_continues++;
            origin = payload.w_p + EPSILON * direction;
            continue;
        }

        /* Save reflected image worldspace position for specular motion vector */
        if ((bounce == 1) && (entity_id != -1)) {
            w_p_r = w_p;
            reflected_entity_id = entity_id;     
        }

        /* Do next event estimation */
        float visibility = 1.0, l_dist;
        vec3 w_l, curr_diffuse_radiance, curr_specular_radiance;
        last_direct_light_entity_id = -1;
        
        bool force_specular = (bounce == 0);
        Irradiance irradiance;
        if (is_ltc_enabled()) {
            irradiance = sample_direct_light_analytic(mat, backface, /* allow shadows */ true, 
            // /*force_diffuse*/!force_specular, /*force_specular*/force_specular, /*force_perfect_reflection*/false, 
            /*force_diffuse*/false, /*force_specular*/force_specular, /*force_perfect_reflection*/false, 
            w_p, w_z, w_x, w_y, w_o);
        } else {
            int light_entity_id = -1;
            float diffuse_visibility, specular_visibility, dist;
            vec3 w_l;
            irradiance = sample_direct_light_stochastic(mat, backface, 
            // /*force_diffuse*/!force_specular, /*force_specular*/force_specular, /*force_perfect_reflection*/false, 
            /*force_diffuse*/false, /*force_specular*/force_specular, /*force_perfect_reflection*/false, 
            w_p, w_z, w_x, w_y, w_o,
            light_entity_id, diffuse_visibility, specular_visibility, w_l, dist);
            irradiance.diffuse *= diffuse_visibility;
            irradiance.specular *= specular_visibility;
        }

        // Reduce fireflies by only accounting for specular irradiance when no hit was diffuse
        irradiance.specular = mix(irradiance.specular, vec3(0.0), max_roughness);

        // If at bounce 0, we don't include diffuse color with diffuse. 
        // That will be multiplied later during compositing and after denoising
        if (bounce == 0 ){
            vec3 specular = mix(vec3(1.0), mat.base_color.rgb, mat.metallic);                        
            curr_specular_radiance = irradiance.specular * specular;
            specular_radiance += path_throughput * curr_specular_radiance;
            direct_specular_radiance = specular_radiance;
        } 
        // Ignoring specular radiance here, since it causes caustics which cannot be easily denoised
        // Ideally, we'll compute caustics some other way
        else {
            vec3 diffuse = mat.base_color.rgb * (1.f - mat.metallic) * (1.f - mat.transmission);
            vec3 specular = mix(vec3(1.0), mat.base_color.rgb, mat.metallic);
            curr_diffuse_radiance = irradiance.diffuse * diffuse;
            curr_specular_radiance = irradiance.specular * specular; 
            specular_radiance += path_throughput * (curr_diffuse_radiance + curr_specular_radiance);
        }
        
        /* Increase bounce count*/
        bounce++;
        if (bounce > max_path_depth) break;
        
        /* Setup next ray */
        vec3 w_i; float pdf, dpdf, spdf;
        vec3 bsdf, dbsdf, sbsdf;
        sample_disney_bsdf(mat, backface,
            w_z, w_o, w_x, w_y, 
            // /*force_diffuse*/!force_specular, /*force_specular*/force_specular, /*force_perfect_reflection*/false, 
            /*force_diffuse*/false, /*force_specular*/force_specular, /*force_perfect_reflection*/false, 
            w_i, pdf, dpdf, spdf, bsdf, dbsdf, sbsdf);

        if (pdf < EPSILON || (all(lessThan(bsdf, vec3(EPSILON))))) break;

        // /* for denoising, we factor out the diffuse and specular bsdfs for primary hits */
        // if (bounce == 1) {
        //     if (spdf > EPSILON && all(greaterThan(sbsdf, vec3(EPSILON))))
        //         path_throughput *= sbsdf / spdf;
        //     else
        //         path_throughput *= 0;
        //     path_throughput *= (1.0 - (mat.roughness * mat.roughness)); // testing
        // }
        // else 
        path_throughput *= bsdf / pdf;

        if (bounce == 1) {
            path_throughput *= (1.0 - (mat.roughness * mat.roughness)); // testing
        }

        /* Trace a ray through the scene */
        origin = offset_ray(w_p, w_z); direction = w_i;
        payload.is_shadow_ray = false;
        traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);
    } while (bounce <= max_path_depth);

    /* Compute specular motion vector */

    if (reflector_is_flat || are_flat_reflectors_forced())
    {
        // Compute previous reflector normals
        EntityStruct reflector_entity; TransformStruct reflector_transform;
        EntityStruct reflected_entity; TransformStruct reflected_transform;
        unpack_entity_struct(first_entity_id, reflector_entity);
        unpack_entity_struct(reflected_entity_id, reflected_entity);

        reflector_transform = tbo.transforms[reflector_entity.transform_id];
        if (reflected_entity.initialized == 1) {
            reflected_transform = tbo.transforms[reflected_entity.transform_id];
        }
        
        // Compute previous reflector position
        vec3 w_p_s_prev = vec3(reflector_transform.localToWorldPrev * reflector_transform.worldToLocal * vec4(w_p_s, 1.0));
        
        // Compute previous reflected position (if sky, previous is the same as current)
        vec3 w_p_r_prev = w_p_r;
        if (reflected_entity.initialized == 1) {
            w_p_r_prev = vec3(reflected_transform.localToWorldPrev * reflected_transform.worldToLocal * vec4(w_p_r, 1.0));
        }
        
        // position of reflected image in world space
        vec3 w_p_i = w_p_s + reflect(w_p_r - w_p_s, w_n_s);
        vec3 w_p_i_prev = w_p_s_prev + reflect(w_p_r_prev - w_p_s_prev, w_n_s);

        vec4 v_p_curr = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(w_p_i, 1.0);
        vec4 v_p_prev = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocalPrev * vec4(w_p_i_prev, 1.0);
        specular_motion = ((v_p_prev.xyz / v_p_prev.w) - (v_p_curr.xyz / v_p_curr.w));
    }

    // Thin film approximation
    else 
    {
        // Compute previous reflector normals
        EntityStruct reflector_entity; TransformStruct reflector_transform;
        EntityStruct reflected_entity; TransformStruct reflected_transform;
        unpack_entity_struct(first_entity_id, reflector_entity);
        unpack_entity_struct(reflected_entity_id, reflected_entity);

        reflector_transform = tbo.transforms[reflector_entity.transform_id];
        if (reflected_entity.initialized == 1) {
            reflected_transform = tbo.transforms[reflected_entity.transform_id];
        }

        // Create basis around reflector normal
        vec3 w_x_s, w_y_s;
        directionOfAnisotropicity(w_n_s, w_x_s, w_y_s);
        w_x_s = normalize(w_x_s); w_y_s = normalize(w_y_s); // just in case while debugging...

        mat3 normLocalToWorld = transpose(mat3(reflector_transform.worldToLocal));
        mat3 normWorldToLocal = transpose(mat3(reflector_transform.localToWorld));//inverse(normLocalToWorld);
        mat3 normLocalToWorldPrev = transpose(mat3(reflector_transform.worldToLocalPrev));

        vec3 m_x_s = normalize(normWorldToLocal * w_x_s);
        vec3 m_y_s = normalize(normWorldToLocal * w_y_s);
        vec3 m_n_s = normalize(normWorldToLocal * w_n_s);

        vec3 w_x_s_prev = normalize(normLocalToWorldPrev * m_x_s);
        vec3 w_y_s_prev = normalize(normLocalToWorldPrev * m_y_s);
        vec3 w_n_s_prev = normalize(normLocalToWorldPrev * m_n_s);
        
        // Compute previous reflector position
        vec3 w_p_s_prev = vec3(reflector_transform.localToWorldPrev * reflector_transform.worldToLocal * vec4(w_p_s, 1.0));
        
        // Compute previous reflected position (if sky, previous is the same as current)
        vec3 w_p_r_prev = w_p_r;
        if (reflected_entity.initialized == 1) {
            w_p_r_prev = vec3(reflected_transform.localToWorldPrev * reflected_transform.worldToLocal * vec4(w_p_r, 1.0));
        }
        
        float to_reflected = distance(w_p_r, w_p_s);
        float to_reflected_prev = distance(w_p_r_prev, w_p_s_prev);

        // Thin lens approximation
        float x_s = dot(w_x_s, normalize(w_p_r - w_p_s) * to_reflected);
        float y_s = dot(w_y_s, normalize(w_p_r - w_p_s) * to_reflected);
        float z_s = dot(w_n_s, normalize(w_p_r - w_p_s) * to_reflected);
        float z_i = 1.0 / reflector_curvature;
        float x_i = (-z_i/z_s)*x_s;
        float y_i = (-z_i/z_s)*y_s;

        float x_s_prev = dot(w_x_s, normalize(w_p_r_prev - w_p_s) * to_reflected_prev);
        float y_s_prev = dot(w_y_s, normalize(w_p_r_prev - w_p_s) * to_reflected_prev);
        float z_s_prev = dot(w_n_s, normalize(w_p_r_prev - w_p_s) * to_reflected_prev);
        float z_i_prev = 1.0 / reflector_curvature;
        float x_i_prev = (-z_i_prev/z_s_prev)*x_s_prev;
        float y_i_prev = (-z_i_prev/z_s_prev)*y_s_prev;

        // position of reflected image in world space
        vec3 w_p_i = w_p_s + w_x_s * x_i + w_y_s * y_i + w_n_s * z_i;
        vec3 w_p_i_prev = w_p_s + w_x_s_prev * x_i_prev + w_y_s_prev * y_i_prev + w_n_s_prev * z_i_prev;

        // float i_dist = distance(w_p_i, w_p_s);
        // float i_dist_prev = distance(w_p_i_prev, w_p_s_prev);

        // w_p_i = i_dist * (first_direction) + w_p_s;
        // w_p_i_prev = i_dist_prev * (first_direction) + w_p_s_prev;

        vec4 v_i_curr = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(w_p_i, 1.0);
        vec4 v_i_prev = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(w_p_i_prev, 1.0);
        vec3 image_motion = ((v_i_prev.xyz / v_i_prev.w) - (v_i_curr.xyz / v_i_curr.w)) * .5;
        
        vec4 v_r_curr = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocal * vec4(w_p_s, 1.0);
        vec4 v_r_prev = camera.multiviews[multiview_idx].viewproj * camera_transform.worldToLocalPrev * vec4(w_p_s_prev, 1.0);
        vec3 reflector_motion = ((v_r_prev.xyz / v_r_prev.w) - (v_r_curr.xyz / v_r_curr.w));
        specular_motion = image_motion + reflector_motion;
    }

    if (reflected_entity_id == -1) specular_motion = vec3(0);

    /* Write to G Buffers */
    vec3 indirect_specular_radiance = specular_radiance - direct_specular_radiance;

    // Specular motion vector
    imageStore(gbuffers[SPECULAR_MOTION_ADDR], tile, vec4(specular_motion, ((first_entity_id == -1) || (reflected_entity_id == -1)) ? 1.0 : 0.0));
    
    // Direct Glossy
    imageStore(gbuffers[GLOSSY_DIRECT_ADDR], tile, vec4(direct_specular_radiance, 1.0));

    // Indirect Glossy 
    imageStore(gbuffers[GLOSSY_INDIRECT_ADDR], tile, vec4(indirect_specular_radiance, 1.0));

    // First reflected object
    temp = imageLoad(gbuffers[REFLECTED_ID_ADDR_AND_PREV], tile);
    imageStore(gbuffers[REFLECTED_ID_ADDR_AND_PREV], tile, vec4(reflected_entity_id, temp.r, 0.0, 1.0));

    // direct_specular_radiance = vec3(pixel_seed, frame_seed);
    // indirect_specular_radiance = vec3(pixel_seed, frame_seed);

    // direct_specular_radiance = vec3(first_barycentrics, first_bary_entity_id);
    // indirect_specular_radiance = vec3(first_barycentrics, first_bary_entity_id);

    // direct_specular_radiance = indirect_specular_radiance = first_direction;

    // Luminance
    temp = imageLoad(gbuffers[LUMINANCE_ADDR], tile);
    imageStore(gbuffers[LUMINANCE_ADDR], tile, vec4(temp.r, 
                                                    temp.g, 
                                                    luminance(direct_specular_radiance),
                                                    luminance(indirect_specular_radiance)));
    
    imageStore(gbuffers[COARSE_SPECULAR_ENTITY_TRI_BARYCENTRIC_ADDR], tile, vec4(first_barycentrics, first_bary_entity_id, first_tri_id));
    imageStore(gbuffers[COARSE_SPECULAR_CAMERA_DIRECTION_ADDR], tile, vec4(first_direction, 1.0));
    imageStore(gbuffers[SPECULAR_SEED_ADDR], tile, vec4(pixel_seed, frame_seed, seed_reprojected));
}

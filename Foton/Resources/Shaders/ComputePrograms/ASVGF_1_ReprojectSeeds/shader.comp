#version 460

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Random.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

#define ENABLE_POSITION_TEST true
#define ENABLE_NORMAL_TEST true
#define ENABLE_ID_TEST true

void main() {
    // Stride of the gradient tile
    const int stride = GRADIENT_TILE_SIZE;
    if ((int(gl_GlobalInvocationID.x * stride) >= push.consts.width)
    || (int(gl_GlobalInvocationID.y * stride) >= push.consts.height)) return;

    // Compute random offset within tile
    int rand_curr;
    if (GRADIENT_USE_RANDOM) {
        init_random(ivec2(gl_GlobalInvocationID.xy), push.consts.frame, 0);
        rand_curr = int(random() * stride * stride);
    } else {
        rand_curr = push.consts.frame;
    }
    ivec2 tile = ivec2(gl_GlobalInvocationID.xy);
    ivec2 offset_curr = ivec2(rand_curr / stride, rand_curr % stride);

    // Compute motion vector
    ivec2 ipos = (stride * tile + offset_curr);
    precise vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos);
    precise vec2 v = motion_data.xy * vec2(.5, -.5);
    precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
    iv.x = (abs(iv.x) < MOTION_VECTOR_MIN) ? 0 : iv.x;
    iv.y = (abs(iv.y) < MOTION_VECTOR_MIN) ? 0 : iv.y;
    ivec2 ipos_prev = ivec2(ipos + (iv + MOTION_VECTOR_OFFSET));

    // Skip if reprojection would fall off the screen
    bool accept = true;
    bvec2 a = greaterThan(ipos_prev, vec2(push.consts.width-1, push.consts.height-1));
    bvec2 b = lessThan(ipos_prev, vec2(0.0, 0.0));
    accept = accept && (!any(bvec2(any(a), any(b))));
    if (!accept) return;
    
    // Load GBuffer data
    vec4 id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR_PREV], ipos_prev);
    vec4 target_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos);
    if ((int(id_data.r) == -1) || (int(target_id_data.r) == -1)) return;
    if (int(id_data.r) != int(target_id_data.r)) return;

    vec4 position_depth = imageLoad(gbuffers[POSITION_DEPTH_ADDR_PREV], ipos_prev);
    vec4 target_pos_depth_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    if ( distance(position_depth.xyz,  target_pos_depth_data.xyz) > .01 ) return;

    vec4 normal = imageLoad(gbuffers[NORMAL_ADDR_PREV], ipos_prev);
    vec4 target_normal = imageLoad(gbuffers[NORMAL_ADDR], ipos);
    if (dot(normal.rgb, target_normal.rgb) < 0.9) return;

    // Load gbuffer data that might change lighting locally from previous to next,  
    // then store to reprojected position. Any changes to lighting from previous
    // frame to now will be due to changes in external lighting conditions
    vec4 seed = imageLoad(gbuffers[SEED_ADDR_PREV], ipos_prev);
    imageStore(gbuffers[SEED_ADDR], ipos, seed);

    vec4 lum = imageLoad(gbuffers[LUMINANCE_ADDR_PREV], ipos_prev);
    imageStore(gbuffers[LUMINANCE_ADDR], ipos, lum);
    
    vec4 albedo = imageLoad(gbuffers[DIFFUSE_COLOR_ADDR_PREV], ipos_prev);
    imageStore(gbuffers[DIFFUSE_COLOR_ADDR], ipos, albedo);
    
    vec4 uv = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR_PREV], ipos_prev);
    imageStore(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ipos, uv);
    
    imageStore(gbuffers[POSITION_DEPTH_ADDR], ipos, position_depth);
    imageStore(gbuffers[NORMAL_ADDR], ipos, normal);
}
#version 460
// We're interested in computing the temporal gradient for the current frame i
// at a forward projected pixel location j.

// This cam be computed by taking the difference between two shading sample 
// functions, f_[i] - f_[i-1]

// This shading sample function is parameterized by a surface sample G and a 
// random seed S

// Specificly, the current shading sample function f_[i] is parameterized by the
// surface sample G from the frame i-1, forward projected to the current frame
// using motion vectors. It's parameterized by a seed as well, which is 
// forward projected to the current frame.

// The previous shading sample function f_[i-1] is parameterized by the surface 
// sample G from the frame i-1 (not forward projected), and by the seed from 
// the previous frame i-1 (also not forward projected). The result of this 
// shading sample function is the sample from the previous frame.

// Note that only a subset of the previous samples satisfy the above criteria.
// specifically, only a subset use reprojected samples.

// In practice, we only care about the luminance of the sample from the previous
// frame, which is stored alongside the seed.

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Random.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

void main()
{
	bool upsampling = false;//is_bilateral_upsampling_enabled();
	if (upsampling) {
        if (int(gl_GlobalInvocationID.x) >= push.consts.width) return;
        if (int(gl_GlobalInvocationID.y) >= push.consts.height) return;
    }
    else {
        if (int(gl_GlobalInvocationID.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
        if (int(gl_GlobalInvocationID.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;
    }

	const int max_rad = 3;// * PATH_TRACE_TILE_SIZE;
	const float hist_len_thresh = max_rad;

	ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 ipos_full = ivec2(gl_GlobalInvocationID.xy) * (upsampling ? 1 : PATH_TRACE_TILE_SIZE) ;
    vec4 variance;
    vec4 average;
    // float histlen = imageLoad(gbuffers[SAMPLE_COUNT_ADDR], ipos).a;
	// vec4 current_position_depth_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos);
	int q_eid = int(imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full).x);

	vec4 direct_diffuse = vec4(0.); 
	vec4 indirect_diffuse = vec4(0.); 
	vec4 direct_glossy = vec4(0.); 
	vec4 indirect_glossy = vec4(0.); 
	// float avg_direct_luminance = 0.0;
	// float avg_direct_luminance_w = 0.0;
	// float avg_indirect_luminance = 0.0;
	// float avg_luminance_w = 0.0;

	// vec4 normal_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos);
	// vec3 n_center = normal_id_data.xyz;
	// int mesh_id_center = int(normal_id_data.w);
	

	// TODO if history_length < 4, estimate variance spatially
	// float alpha = clamp((hist_len_thresh - clamp(histlen, 0, hist_len_thresh) ) / hist_len_thresh, 0.0, 1.0);
	const int r = 1;//int(mix(0, max_rad, alpha));
	if( (r > 0) && (q_eid != -1)) {
		float sum_w = 0.0;
		average = vec4(0.0);
		variance = vec4(0.0);
		for(int yy = -r; yy <= r; yy++) {
			for(int xx = -r; xx <= r; xx++) {
				ivec2 p = ipos + ivec2(xx, yy);
				ivec2 p_full = p * (upsampling ? 1 : PATH_TRACE_TILE_SIZE);

				int p_eid = int(imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], p_full).x);
				float w = (p_eid == q_eid) ? 1.0 : 0.0;
				w *= exp(-pow(length(vec2(xx,yy)), 2) / (pow(max(r,1)*.5, 2)));
				if(isnan(w)) continue;
				sum_w += w;

				vec4 dd_p = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], p);
				vec4 id_p = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], p);
				vec4 dg_p = imageLoad(gbuffers[GLOSSY_DIRECT_ADDR], p);
				vec4 ig_p = imageLoad(gbuffers[GLOSSY_INDIRECT_ADDR], p);
				vec4 l = imageLoad(gbuffers[LUMINANCE_ADDR], p);

				average += l * w;
				variance += l * l * w;				
				direct_diffuse.rgb += dd_p.rgb * w;
				indirect_diffuse.rgb += id_p.rgb * w;
				direct_glossy.rgb += dg_p.rgb * w;
				indirect_glossy.rgb += ig_p.rgb * w;
				
				// avg_direct_luminance += l.r;
				// avg_indirect_luminance += l.g;
				// avg_luminance_w += 1;
			}
		}

		if (sum_w > 0) {
			average /= sum_w;
			variance /= sum_w;
			// moments /= sum_m_w;
			direct_diffuse.rgb /= sum_w;
			indirect_diffuse.rgb /= sum_w;
			direct_glossy.rgb /= sum_w;
			indirect_glossy.rgb /= sum_w;
		}

		// /*TESTING firefly supression */
		// vec4 curr_direct = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipos);
		// vec4 curr_indirect = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos);

		// if (alpha > .1) {
			// curr_direct.rgb = direct.rgb;
			// curr_indirect.rgb = indirect.rgb;
		// }
		// if (avg_luminance_w > 0) {
		// 	avg_luminance /= avg_luminance_w;

		// 	if (luminance(direct.rgb) > avg_luminance ) {
		// 		curr_direct.rgb = direct.rgb;
		// 	}

		// 	if (luminance(indirect.rgb) > avg_luminance ) {
		// 		curr_indirect.rgb = indirect.rgb;
		// 	}
		// }
			

		vec4 variance_temporal = abs(average - variance * variance);
        imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], ipos, vec4(direct_diffuse.rgb, variance_temporal.r));
        imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos, vec4(indirect_diffuse.rgb, variance_temporal.g));
		imageStore(gbuffers[GLOSSY_DIRECT_ADDR], ipos, vec4(direct_glossy.rgb, variance_temporal.b));
        imageStore(gbuffers[GLOSSY_INDIRECT_ADDR], ipos, vec4(indirect_glossy.rgb, variance_temporal.a));
		// imageStore(gbuffers[VARIANCE_ADDR], ipos, vec4(variance_temporal));
	}
	else if (q_eid != -1)
	{
		vec4 variance = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR], ipos);
    	vec4 average = imageLoad(gbuffers[LUMINANCE_AVERAGE_ADDR], ipos);
		vec4 variance_temporal = abs(average - variance * variance);

		direct_diffuse = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipos);
		indirect_diffuse = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos);
		direct_glossy = imageLoad(gbuffers[GLOSSY_DIRECT_ADDR], ipos);
		indirect_glossy = imageLoad(gbuffers[GLOSSY_INDIRECT_ADDR], ipos);
        imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], ipos, vec4(direct_diffuse.rgb, variance_temporal.r));
        imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos, vec4(indirect_diffuse.rgb, variance_temporal.g));
		imageStore(gbuffers[GLOSSY_DIRECT_ADDR], ipos, vec4(direct_glossy.rgb, variance_temporal.b));
        imageStore(gbuffers[GLOSSY_INDIRECT_ADDR], ipos, vec4(indirect_glossy.rgb, variance_temporal.a));
	}
	else {
		// direct = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipos);
		// indirect = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos);
		// float variance_temporal = max(0.0, moments.y - moments.x * moments.x);
        // imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], ipos, vec4(direct.rgb, variance_temporal));
        // imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos, vec4(indirect.rgb, variance_temporal));

		// imageStore( gbuffers[VARIANCE_ADDR], ipos, vec4(variance_temporal));
    }
}

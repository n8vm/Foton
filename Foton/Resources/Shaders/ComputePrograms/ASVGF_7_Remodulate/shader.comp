#version 460

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"

#include "Foton/Resources/Shaders/Common/DisneyBSDF.hxx"
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

vec3 Uncharted2Tonemap(vec3 x)
{
    x = max(x, vec3(0));
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E_ = 0.02;
	float F = 0.30;
	return max(vec3(0.0f), ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F))-E_/F);
}

void main() {
    bool upsampling = is_bilateral_upsampling_enabled();
    if (upsampling) {
        if (int(gl_GlobalInvocationID.x) >= push.consts.width) return;
        if (int(gl_GlobalInvocationID.y) >= push.consts.height) return;
    }
    else {
        if (int(gl_GlobalInvocationID.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
        if (int(gl_GlobalInvocationID.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;
    }

    const ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 ipos_full = ivec2(gl_GlobalInvocationID.xy) * (upsampling ? 1 : PATH_TRACE_TILE_SIZE) ;
    init_random(ipos, push.consts.frame, 0);
    vec3 color;

    vec4 temp = imageLoad(gbuffers[DIFFUSE_SEED_ADDR], ipos);
    ivec2 pixel_seed = ivec2(temp.xy);
    int frame_seed = int(temp.z);

    vec3 origin, direction;
    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    int multiview_idx = push.consts.viewIndex;
    multiview_idx = 0; // temporary

    get_origin_and_direction(
        pixel_seed, frame_seed,
        camera.multiviews[multiview_idx].projinv,
        camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv,
        ipos_full, ivec2(push.consts.width, push.consts.height), origin, direction);
        
    // Normal G Buffer
    temp = imageLoad(gbuffers[NORMAL_ADDR], ipos_full);
    vec3 w_n = temp.xyz;
    
    // ID G Buffer
    temp = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full);
    int entity_id = int(temp.r);


    // vec3 diffuse_color = vec3(0);
    vec3 diffuse_direct = vec3(0);
    vec3 diffuse_indirect = vec3(0);

    // vec3 glossy_color = vec3(0);
    vec3 glossy_direct = vec3(0);
    vec3 glossy_indirect = vec3(0);

    // vec3 transmission_color = vec3(0);
    vec3 transmission_direct = vec3(0);
    vec3 transmission_indirect = vec3(0);

    vec3 environment = vec3(0);
    vec3 emission = vec3(0);
    
    if (entity_id == -1) {
        environment.rgb = get_environment_color(direction) * push.consts.environment_intensity;
    }

    if (entity_id != -1) {
        // Position G Buffer 
        temp = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos_full);
        vec3 w_p = temp.xyz;
        float depth = temp.w;

        // UV G Buffer
        temp = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ipos_full);
        vec2 uv = temp.xy;

        // // Raw albedo
        // temp = imageLoad(gbuffers[DIFFUSE_COLOR_ADDR], ipos);
        // vec3 albedo = temp.xyz;

        EntityStruct entity; MaterialStruct mat; LightStruct light;
        unpack_entity_struct(entity_id, entity);
        unpack_material_struct(entity_id, entity, uv, w_p, mat);
        unpack_light_struct(entity_id, entity, light);
        
        vec3 w_n_f = /*(backface) ? -w_n : */w_n;
        vec3 w_o = -direction;
        vec3 w_s = reflect(-w_o, w_n);
        vec3 w_i = w_s;
        vec3 w_h = (w_i+w_o)/length(w_i+w_o);

        float f0 = 0.01;
        float F = f0 + (1.0 - f0) * pow(1.0 - max(0, dot(w_h, w_i )), 5);

        vec3 temp;
        float m = disney_diffuse(mat, w_n_f, w_o, w_i, temp) * (1.f - mat.metallic) * (1.f - mat.transmission);
        float mat_estimator = pow2(1.0 - F)*m*M_PI;
        float specular_estimator = F + (1.0 - F);
        
        // * (max(mat.metallic, 1.0 - (mat.roughness * mat.roughness)));
        // diffuse_color *= mat_estimator;
        // glossy_color = vec3(1.0); // not controllable via disney bsdf. might change though...
        // glossy_color *= specular_estimator;

        // transmission_color = vec3(0.0); // not controllable via disney bsdf. might change though...

        vec3 denoised_diffuse_direct = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipos).rgb;
        vec3 denoised_diffuse_indirect = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos).rgb;
        vec3 denoised_glossy_direct = imageLoad(gbuffers[GLOSSY_DIRECT_ADDR], ipos).rgb;
        vec3 denoised_glossy_indirect = imageLoad(gbuffers[GLOSSY_INDIRECT_ADDR], ipos).rgb;
        
        // vec3 diffuse_illumination = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipos).rgb;
        // vec3 glossy_illumination = imageLoad(gbuffers[GLOSSY_ILLUM_VAR_ADDR], ipos).rgb;
        
        diffuse_direct = denoised_diffuse_direct * mat_estimator;
        diffuse_indirect = denoised_diffuse_indirect * mat_estimator;//vec3(0); // todo, separate from direct

        glossy_direct = denoised_glossy_direct * specular_estimator;
        glossy_indirect = denoised_glossy_indirect * specular_estimator; // todo...

        transmission_direct = vec3(0); // todo...
        transmission_indirect = vec3(0); // todo...

        if ((entity.light_id >= 0) && (entity.light_id < max_lights)) {
            emission = light.color.rgb * light.intensity;
        }      
    }

    imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], ipos, vec4(diffuse_direct, 1.0));
    imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos, vec4(diffuse_indirect,1.0));

    imageStore(gbuffers[GLOSSY_DIRECT_ADDR], ipos, vec4(glossy_direct, 1.0));
    imageStore(gbuffers[GLOSSY_INDIRECT_ADDR], ipos, vec4(glossy_indirect,1.0));

    imageStore(gbuffers[EMISSION_ADDR], ipos, vec4(emission, 1.0));
    imageStore(gbuffers[ENVIRONMENT_ADDR], ipos, vec4(environment, 1.0));
}
#version 460
#pragma optionNV (unroll all)

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

// Tends to blur out details, but makes convergence more stable
#define RADIUS 0

#if RADIUS == 2
const float h[5][5] = {
    {1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0},
    {1.0/64.0,  1.0/16.0, 3.0/32.0,  1.0/16.0, 1.0/64.0},
    {3.0/128.0, 3.0/32.0, 9.0/64.0,  3.0/32.0, 3.0/128.0},
    {1.0/64.0,  1.0/16.0, 3.0/32.0,  1.0/16.0, 1.0/64.0},
    {1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0}
};
#endif

// sigma .20
#if RADIUS == 1
const float h[3][3] = {
    {1.0/16.0, 1.0/8.0,  1.0/16.0},
    {1.0/8.0,  1.0/4.0,  1.0/8.0},
    {1.0/16.0, 1.0/8.0,  1.0/16.0},
};
#endif

#if RADIUS == 0
float Coefficients[1] = {
    1.0
};

const float h[1][1] = {
    {1.0},
};
#endif


// NOTE, HOW TO ADDRESS DIFFERENT MOTION VECTOR FOR GRADIENT SEED?
void main() {
    if (int(gl_GlobalInvocationID.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
    if (int(gl_GlobalInvocationID.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;
    
    float screen_correction = max(push.consts.width, push.consts.height) / PATH_TRACE_TILE_SIZE;
    float r_sigma_indirect = 10.0 * (1.0 - sqrt(.5)) * screen_correction; // user controllable power

    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 ipos_full = ivec2(gl_GlobalInvocationID.xy) * PATH_TRACE_TILE_SIZE;
    float gradient_weight = push.consts.parameter1;

    // This temporal accumulation uses two ping pong buffers per accumulated
    // g buffer. These are the current and next gbuffer addreses for each.
    const int curr_specular_hist_addr   = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_7_ADDR : SVGF_TAA_HISTORY_8_ADDR;
    const int next_specular_hist_addr   = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_8_ADDR : SVGF_TAA_HISTORY_7_ADDR;
    
    // Compute motion vector
    // Note, the w component indicates an invalid motion vector, which can 
    // occur for pixels containing the background
    bool reset = false;
    precise vec4 motion_data = imageLoad(gbuffers[GLOSSY_MOTION_ADDR], ipos);
    if (motion_data.w > 0) reset = true; // reset history if motion data is invalid
    precise vec2 v = motion_data.xy * vec2(.5, -.5);
    precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height) / PATH_TRACE_TILE_SIZE;
    iv.x = (abs(iv.x) < MOTION_VECTOR_MIN) ? 0 : iv.x;
    iv.y = (abs(iv.y) < MOTION_VECTOR_MIN) ? 0 : iv.y;
    ivec2 pos_prev = ivec2(ipos + iv + MOTION_VECTOR_OFFSET);
    ivec2 p = ivec2(pos_prev - 0.5);

    // Load g buffer data which we'll use for detecting disocclusions
    int curr_entity_id = int(imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full).r);
    int curr_refl_entity_id = int(imageLoad(gbuffers[REFLECTED_ID_ADDR_AND_PREV], ipos).r);
    vec4 curr_spec_axis_sharpness = imageLoad(gbuffers[LOBE_AXIS_SHARPNESS_ADDR], ipos_full); 
    vec3 curr_normal = imageLoad(gbuffers[NORMAL_ADDR], ipos_full).rgb;
    
    // Load g buffer data to be temporally accumulated
	vec4  specular_curr     = imageLoad(gbuffers[GLOSSY_INDIRECT_ADDR], ipos);
	vec2  moments_curr = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR], ipos).rg;
    
    // We'll be estimating these values by a simple filter surrounding the reprojected position
    vec4 specular_prev  = vec4(0);
    float antilag_prev = 0;
	vec2 moments_prev = vec2(0);
	float sum_w       = 0.0;
	float histlen     = 0.0;
    if (!reset) {
        vec4 specular_max;
        vec4 specular_min;

        float min_luminance;
        bool first = true;

        const int r = RADIUS;
        for (int y = -r; y <= r; ++y) {
            for (int x = -r; x <= r; ++x) {
                ivec2 ipos_prev = pos_prev + ivec2(x, y);
                ivec2 ipos_prev_full = ipos_prev * PATH_TRACE_TILE_SIZE;
                
                // Load disocclusion gbuffer data
                int hist_entity_id = int(imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_prev_full));
                int hist_refl_entity_id = int(imageLoad(gbuffers[REFLECTED_ID_ADDR_AND_PREV], ipos_prev).g);

                vec4 hist_spec_axis_sharpness = imageLoad(gbuffers[LOBE_AXIS_SHARPNESS_ADDR_PREV], ipos_prev_full); 
                vec3 hist_normal = imageLoad(gbuffers[NORMAL_ADDR_PREV], ipos_prev_full).rgb;

                // Load prior gbuffer data to accumulate temporally 
                vec4 specular = imageLoad(gbuffers[curr_specular_hist_addr], ipos_prev);
                                
                bvec2 a = greaterThan(ipos_prev, vec2(push.consts.width-1, push.consts.height-1));
                bvec2 b = lessThan(ipos_prev, vec2(0.0, 0.0));
                
                // Determine if this prior sample is a disocclusion. If not, accept it.
                bool accept = true;
                accept = accept && (!any(bvec2(any(a), any(b))));
                accept = accept && (!any(isnan(specular)));
                accept = accept && (!any(isinf(specular)));
                accept = accept && (hist_entity_id == curr_entity_id);
                // accept = accept && (dot(curr_normal, hist_normal) > .9); 
                
                // sharpness
                float lambda_q = hist_spec_axis_sharpness.w;
                float lambda_p = curr_spec_axis_sharpness.w;
                                
                // lobe axis
                vec3 xi_q = hist_spec_axis_sharpness.xyz;
                vec3 xi_p = curr_spec_axis_sharpness.xyz;

                // float direct_lobe_axis_similarity = exp(((r_sigma_direct*lambda_p*lambda_q)/(lambda_p + lambda_q)) * (dot(xi_p,xi_q) - 1.0f));
                // float direct_lobe_sharpness_similarity = pow( (2.0 * sqrt(lambda_p * lambda_q)) / (lambda_p + lambda_q), r_sigma_direct);
                // float wr_direct = direct_lobe_axis_similarity * direct_lobe_sharpness_similarity;

                float indirect_lobe_axis_similarity = exp(((r_sigma_indirect*lambda_p*lambda_q)/(lambda_p + lambda_q)) * (dot(xi_p,xi_q) - 1.0f));
                float indirect_lobe_sharpness_similarity = pow( (2.0 * sqrt(lambda_p * lambda_q)) / (lambda_p + lambda_q), r_sigma_indirect);
                float wr_indirect = indirect_lobe_axis_similarity * indirect_lobe_sharpness_similarity;

                float w_id_indirect = mix(1.0, (curr_refl_entity_id == hist_refl_entity_id) ? 1.0 : 0.0, curr_spec_axis_sharpness.w);


                float normal_similarity = exp(((r_sigma_indirect*lambda_p*lambda_q)/(lambda_p + lambda_q)) * (dot(curr_normal,hist_normal) - 1.0f));

                float w = h[y + RADIUS][x + RADIUS] * wr_indirect * normal_similarity * w_id_indirect;
                
                if (accept) {                   
                    specular_prev += specular * w;
                    sum_w        += w;
                }
            }
        }
    }

    // Compute the antilag alpha based off of temporal gradient
    vec4 antilag_alpha = vec4(0.0);
    if (is_gradient_estimation_enabled())
	{
		const int r = GRADIENT_FILTER_RADIUS;
        float w_sum = 0.f;
		for(int y = -r; y <= r; y++) {
			for(int x = -r; x <= r; x++) {
                ivec2 p = pos_prev / GRADIENT_TILE_SIZE + ivec2(x, y);
				vec4 gradient = imageLoad(gbuffers[TEMPORAL_GRADIENT_ADDR], p); 
				vec4 max_luminance = imageLoad(gbuffers[LUMINANCE_MAX_ADDR], p); 
                max_luminance = max(max_luminance, vec4(1e-4));
				
				vec4 a = gradient / max_luminance;
				float w = 1.0 / float((2 * r + 1) * (2 * r + 1));
				antilag_alpha = max(antilag_alpha, a);
			}
		}

        antilag_alpha *= gradient_weight;
        antilag_alpha = clamp(antilag_alpha, vec4(0.0), vec4(1.0));
        if(any(isnan(antilag_alpha)))
            antilag_alpha = vec4(0.0);
	}

    if (sum_w > 0.0) { /* found sufficiently reliable history information */
        specular_prev   /= sum_w;

        vec4 alpha_color   = vec4(1.0 / MAX_SPECULAR_CUMULATIVE_COUNT);
		alpha_color   = mix(alpha_color, vec4(1.0 / MIN_SPECULAR_CUMULATIVE_COUNT), antilag_alpha);

        vec4 accum_specular = vec4(mix(specular_prev.rgb, specular_curr.rgb, alpha_color.a), 1.0); // note, pass variance as w for bilateral filtering
        
        imageStore( gbuffers[GLOSSY_INDIRECT_ADDR], ipos, accum_specular);
        imageStore( gbuffers[next_specular_hist_addr], ipos, accum_specular );
    } else {
        imageStore( gbuffers[GLOSSY_INDIRECT_ADDR], ipos, specular_curr);
        imageStore( gbuffers[next_specular_hist_addr], ipos, specular_curr);
    }
}
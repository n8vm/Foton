#version 460

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"
#include "Foton/Resources/Shaders/Common/Lights.hxx"
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

void main() {
    /* These are required for shading purposes. Wait until they're ready. */
    if ((push.consts.ltc_mat_lut_id < 0) || (push.consts.ltc_mat_lut_id >= max_textures)) return;
    if ((push.consts.ltc_amp_lut_id < 0) || (push.consts.ltc_amp_lut_id >= max_textures)) return;
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    vec4 temp;

    // Component IDs
    temp = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos);
    int entity_id = int(temp[0]);
    int material_id = int(temp[1]);
    int transform_id = int(temp[2]);
    int light_id = int(temp[3]);
    
    // Seed / Luminance G Buffer
    temp = imageLoad(gbuffers[SEED_LUMINANCE_ADDR], ipos);
    ivec2 pixel_seed = ivec2(temp.xy);
    int frame_seed = int(temp.z);

    // Position G Buffer 
    temp = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    vec3 w_p = temp.xyz;
    float depth = temp.w;

    // Normal G Buffer
    temp = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos);
    vec3 w_n = normalize(temp.xyz);
    vec3 w_t, w_b;
    directionOfAnisotropicity(w_n, w_t, w_b);
    // int entity_id = int(temp.w);

    // UV G Buffer
    temp = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ipos);
    vec2 uv = temp.xy;

    // // Raw albedo
    // temp = imageLoad(gbuffers[DIFFUSE_COLOR_ADDR], ipos);
    // vec3 albedo = temp.xyz;
    init_random(pixel_seed, frame_seed, 0);

    // Compute ray origin and direction
    vec3 origin, direction;
    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    int multiview_idx = push.consts.viewIndex;
    multiview_idx = 0; // temporary
    get_origin_and_direction(
        pixel_seed, frame_seed,
        camera.multiviews[multiview_idx].projinv,
        camera_transform.localToWorld * camera.multiviews[multiview_idx].viewinv,
        ipos, ivec2(push.consts.width, push.consts.height), origin, direction);

    vec3 w_o = -direction;
    bool backface = dot(w_n, w_o) < 0.0;
    backface = false; 
    
    // Unpack data
    MaterialStruct mat; LightStruct light;
    unpack_material_struct(material_id, uv, w_p, mat); // to do, use primary albedo if bounce is 0
    unpack_light_struct(light_id, light);

    // Compute radiance
    Radiance radiance = sample_direct_light_analytic(mat, backface, w_p, w_n, w_t, w_b, w_o) ;
    vec3 emission = ((light_id < 0) || (light_id >= max_lights)) ? vec3(0.0) : light.color.rgb * light.intensity;
    vec3 environment = (entity_id == -1) ? get_environment_color(direction) * push.consts.environment_intensity : vec3(0.0);
    // vec3 raw_albedo = albedo * radiance.diffuse + radiance.specular;
    // imageStore(render_image, ipos, vec4(mat.base_color.rgb * (radiance.diffuse + radiance.specular), 1.0));
    // imageStore(render_image, ipos, vec4(radiance.diffuse + radiance.specular, 1.0));
    
    
    imageStore(gbuffers[DIFFUSE_DIRECT_ADDR], ipos, vec4(radiance.diffuse, 1.0));
    imageStore(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos, vec4(0.0,0.0,0.0,1.0)); //todo...
    imageStore(gbuffers[DIFFUSE_COLOR_ADDR], ipos, mat.base_color);

    imageStore(gbuffers[GLOSSY_DIRECT_ADDR], ipos, vec4(radiance.specular, 1.0));
    imageStore(gbuffers[GLOSSY_INDIRECT_ADDR], ipos, vec4(0.0,0.0,0.0,1.0)); //todo...
    imageStore(gbuffers[GLOSSY_COLOR_ADDR], ipos, vec4(1.0, 1.0, 1.0, 1.0)); //todo...

    imageStore(gbuffers[EMISSION_ADDR], ipos, vec4(emission, 1.0)); //todo...
    
    imageStore(gbuffers[ENVIRONMENT_ADDR], ipos, vec4(environment, 1.0)); //todo...



    //  + radiance.specular
}
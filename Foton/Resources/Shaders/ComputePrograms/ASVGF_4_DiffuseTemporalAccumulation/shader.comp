#version 460
#pragma optionNV (unroll all)

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

// Tends to blur out details, but makes convergence more stable
#define RADIUS 0

#if RADIUS == 2
float Coefficients[25] = 
{
    0.000002,	0.000212,	0.000922,	0.000212,	0.000002,
    0.000212,	0.024745,	0.107391,	0.024745,	0.000212,
    0.000922,	0.107391,	0.466066,	0.107391,	0.000922,
    0.000212,	0.024745,	0.107391,	0.024745,	0.000212,
    0.000002,	0.000212,	0.000922,	0.000212,	0.000002,
};
#endif

// sigma .20
#if RADIUS == 1
float Coefficients[9] = 
{
    0.000039,	0.006133,	0.000039,
    0.006133,	0.975316,	0.006133,
    0.000039,	0.006133,	0.000039,
};
#endif

#if RADIUS == 0
float Coefficients[1] = {
    1.0
};
#endif

void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    float gradient_weight = push.consts.parameter1;

    // This temporal accumulation uses two ping pong buffers per accumulated
    // g buffer. These are the current and next gbuffer addreses for each.
    const int curr_direct_diffuse_hist_addr     = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_1_ADDR : SVGF_TAA_HISTORY_2_ADDR;
    const int next_direct_diffuse_hist_addr     = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_2_ADDR : SVGF_TAA_HISTORY_1_ADDR;
    const int curr_indirect_diffuse_hist_addr   = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_3_ADDR : SVGF_TAA_HISTORY_4_ADDR;
    const int next_indirect_diffuse_hist_addr   = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_4_ADDR : SVGF_TAA_HISTORY_3_ADDR;
    const int curr_sample_avg_addr            = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_7_ADDR : SVGF_TAA_HISTORY_8_ADDR;
    const int next_sample_avg_addr            = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_8_ADDR : SVGF_TAA_HISTORY_7_ADDR;

    // Compute motion vector
    // Note, the w component indicates an invalid motion vector, which forces a reset
    bool reset = false;
    precise vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos);
    if (motion_data.w > 0) reset = true; // reset history if motion data is invalid
    precise vec2 v = motion_data.xy * vec2(.5, -.5);
    precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
    iv.x = (abs(iv.x) < MOTION_VECTOR_MIN) ? 0 : iv.x;
    iv.y = (abs(iv.y) < MOTION_VECTOR_MIN) ? 0 : iv.y;
    ivec2 pos_prev = ivec2(ipos + iv + MOTION_VECTOR_OFFSET);
    ivec2 p = ivec2(pos_prev - 0.5);

    // Load g buffer data which we'll use for detecting disocclusions
    vec4 curr_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos);
    vec4 luminance_variance = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR], ipos);
    vec4 luminance_average = imageLoad(gbuffers[LUMINANCE_AVERAGE_ADDR], ipos);
    vec3 curr_normal = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos).rgb;
    if (int(curr_id_data.a) != -1) reset = true; //if an element is a light, don't accumulate temporally

    // Load g buffer data to be temporally accumulated
    vec4 temp;
    temp = imageLoad(gbuffers[curr_sample_avg_addr], ipos);
    int samples = int(temp.r);
	vec4  direct_diffuse_curr     = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipos);
	vec4  indirect_diffuse_curr     = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], ipos);
    direct_diffuse_curr.w = luminance_variance.r;
    indirect_diffuse_curr.w = luminance_variance.g;
	
    // We'll be estimating these values by a simple filter surrounding the reprojected position
    vec4 direct_diffuse_prev  = vec4(0);
    vec4 indirect_diffuse_prev  = vec4(0);

    // float antilag_prev = 0;
    vec4 hist_prev    = vec4(0);
	float sum_w       = 0.0;
	float histlen     = 0.0;
    if (!reset) {
        const int max_rad = 1;// * PATH_TRACE_TILE_SIZE;
	    const float hist_len_thresh = max_rad + MIN_SAMPLES;
        float alpha = (hist_len_thresh - clamp(samples, 0, hist_len_thresh) ) / hist_len_thresh;
        const int r = int(mix(1, max_rad, alpha));
        for (int y = -r; y <= r; ++y) {
            for (int x = -r; x <= r; ++x) {
                ivec2 ipos_prev = pos_prev + ivec2(x, y);
                
                // Load disocclusion gbuffer data
                vec4 hist_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR_PREV], ipos_prev);
                vec3 hist_normal = imageLoad(gbuffers[NORMAL_ID_ADDR_PREV], ipos_prev).rgb;
                
                // Load prior gbuffer data to accumulate temporally 
                vec4 direct_diffuse = imageLoad(gbuffers[curr_direct_diffuse_hist_addr], ipos_prev);
                vec4 indirect_diffuse = imageLoad(gbuffers[curr_indirect_diffuse_hist_addr], ipos_prev);
                int samples = int(imageLoad(gbuffers[curr_sample_avg_addr], ipos_prev).r);

                // Determine if this prior sample is a disocclusion. If not, accept it.
                bool accept = true;
                bvec2 a = greaterThan(ipos_prev, vec2(push.consts.width-1, push.consts.height-1));
                bvec2 b = lessThan(ipos_prev, vec2(0.0, 0.0));
                accept = accept && (!any(bvec2(any(a), any(b))));
                accept = accept && (!any(isnan(direct_diffuse)));
                accept = accept && (!any(isinf(direct_diffuse)));
                accept = accept && (!any(isnan(indirect_diffuse)));
                accept = accept && (!any(isinf(indirect_diffuse)));
                accept = accept && (int(hist_id_data.r) == int(curr_id_data.r));
                accept = accept && (int(hist_id_data.a) == -1);
                accept = accept && (dot(curr_normal, hist_normal) > .9); 

                if (accept) {
                    float w = 1.;
                    direct_diffuse_prev += direct_diffuse * w;
                    indirect_diffuse_prev += indirect_diffuse * w;
                    histlen      += samples * w;
                    sum_w        += w;
                }
            }
        }
    }

    // Compute the antilag alpha based off of temporal gradient
    vec4 antilag_alpha = vec4(0.0);
    if (is_gradient_estimation_enabled())
	{
		const int r = GRADIENT_FILTER_RADIUS;
        float w_sum = 0.f;
		for(int y = -r; y <= r; y++) {
			for(int x = -r; x <= r; x++) {
				vec4 gradient = imageLoad(gbuffers[TEMPORAL_GRADIENT_ADDR], pos_prev + ivec2(x, y) * GRADIENT_TILE_SIZE); 
				vec4 max_luminance = imageLoad(gbuffers[LUMINANCE_MAX_ADDR], pos_prev + ivec2(x, y) * GRADIENT_TILE_SIZE); 
                max_luminance = max(max_luminance, vec4(1e-4));
				
				vec4 a = gradient / max_luminance;
				float w = 1.0 / float((2 * r + 1) * (2 * r + 1));
				antilag_alpha = max(antilag_alpha, a);
			}
		}

        antilag_alpha *= gradient_weight;
        antilag_alpha = clamp(antilag_alpha, vec4(0.0), vec4(1.0));
        if(any(isnan(antilag_alpha)))
            antilag_alpha = vec4(0.0);

        // antilag_alpha = pow(antilag_alpha, gradient_weight); // testing
        // if (antilag_alpha < .5) antilag_alpha = 0; //testing
	}

    if (sum_w > 0.01) { /* found sufficiently reliable history information */
        direct_diffuse_prev   /= sum_w;
        indirect_diffuse_prev   /= sum_w;
		// moments_prev  /= sum_w;
		// antilag_prev  /= sum_w;
		histlen       /= sum_w;

        // vec4 accum_antilag = antilag_alpha;//mix(antilag_prev, antilag_alpha, GRADIENT_ALPHA);
        // vec4 alpha_color   = vec4(1.0 / MAX_CUMULATIVE_COUNT);

        vec4 alpha_color   = vec4(max(1.0 / MAX_CUMULATIVE_COUNT, 1.0 / (histlen + 1.0)));
		// float alpha_moments = max(0.6, 1.0 / (histlen + 1.0));

        alpha_color   = mix(alpha_color, vec4(1.0), antilag_alpha);
		// alpha_moments = mix(alpha_moments, (1.0 / MAX_CUMULATIVE_COUNT), accum_antilag);
		// vec2 accum_moments = moments_curr;//mix(moments_prev, moments_curr, alpha_moments);
        
        // float variance = abs(accum_moments.y - accum_moments.x * accum_moments.x);  

        
		float color_count   = clamp(histlen, MIN_SAMPLES, MAX_CUMULATIVE_COUNT);
        float moments_count = clamp(histlen, MIN_SAMPLES, MAX_CUMULATIVE_COUNT);

        
        // I don't know why, but mix seems to lose precision... always seems to reduce alpha color. 
		// alpha_color   = mix(alpha_color,   1.0, accum_antilag); 
        // color_count = mix(color_count, 1.0, clamp(accum_antilag, 0.0, 1.0));
		// moments_count = mix(moments_count, 1.0, clamp(accum_antilag, 0.0, 1.0));
		
        // float accum_a = min(MAX_CUMULATIVE_COUNT, histlen);
        float accum_histlen = color_count + 1.0;
	// vec2 accum_moments = mix(moments_prev, moments_curr, 1.0 / moments_count);
        // if (moments_count <= 1) accum_moments.y = 1;
        
    // float variance = abs(accum_moments.y - accum_moments.x * accum_moments.x);
        // if (isnan(variance) ) variance = 200;
        
        // note, w component holds luminance variance
        vec4 accum_direct_diffuse = mix(direct_diffuse_prev, direct_diffuse_curr, alpha_color.r);
        vec4 accum_indirect_diffuse = mix(indirect_diffuse_prev, indirect_diffuse_curr, alpha_color.g);
        

        imageStore( gbuffers[DIFFUSE_DIRECT_ADDR],        ivec2(gl_GlobalInvocationID.xy), accum_direct_diffuse);
        imageStore( gbuffers[DIFFUSE_INDIRECT_ADDR],        ivec2(gl_GlobalInvocationID.xy), accum_indirect_diffuse);
        // imageStore( gbuffers[LUMINANCE_VARIANCE_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(accum_moments, 1.0, accum_histlen));
        // imageStore( gbuffers[SAMPLE_COUNT_ADDR],            ivec2(gl_GlobalInvocationID.xy), vec4(accum_histlen));
        // imageStore( gbuffers[VARIANCE_ADDR],                ivec2(gl_GlobalInvocationID.xy), vec4(variance));
        // imageStore( gbuffers[TEMPORAL_GRADIENT_ADDR],       ivec2(gl_GlobalInvocationID.xy), vec4(accum_antilag));

        imageStore( gbuffers[next_direct_diffuse_hist_addr],        ivec2(gl_GlobalInvocationID.xy), accum_direct_diffuse );
        imageStore( gbuffers[next_indirect_diffuse_hist_addr],        ivec2(gl_GlobalInvocationID.xy), accum_indirect_diffuse );
        // imageStore( gbuffers[next_moments_addr],            ivec2(gl_GlobalInvocationID.xy), vec4(accum_moments, 1.0, 1.0));
        imageStore( gbuffers[next_sample_avg_addr],       ivec2(gl_GlobalInvocationID.xy), vec4(accum_histlen));
        // imageStore( gbuffers[next_grad_addr],       ivec2(gl_GlobalInvocationID.xy), vec4(accum_antilag));

        // imageStore( gbuffers[DEBUG_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(abs(accum_antilag)));

        imageStore( gbuffers[DEBUG_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(abs(luminance_variance.g * 100)));

    } else {
        /* encodes variance */
        // direct_diffuse_curr.w = 200;
        // indirect_diffuse_curr.w = 200;

        imageStore( gbuffers[DIFFUSE_DIRECT_ADDR],        ivec2(gl_GlobalInvocationID.xy), direct_diffuse_curr);
        imageStore( gbuffers[DIFFUSE_INDIRECT_ADDR],        ivec2(gl_GlobalInvocationID.xy), indirect_diffuse_curr);
        // imageStore( gbuffers[LUMINANCE_VARIANCE_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(moments_curr, 1.0, 1.0));
        // imageStore( gbuffers[SAMPLE_COUNT_ADDR],            ivec2(gl_GlobalInvocationID.xy), vec4(1));
        // imageStore( gbuffers[VARIANCE_ADDR],                ivec2(gl_GlobalInvocationID.xy), vec4(200));
        imageStore( gbuffers[next_direct_diffuse_hist_addr],        ivec2(gl_GlobalInvocationID.xy), direct_diffuse_curr);
        imageStore( gbuffers[next_indirect_diffuse_hist_addr],        ivec2(gl_GlobalInvocationID.xy), indirect_diffuse_curr);
        // imageStore( gbuffers[next_moments_addr],            ivec2(gl_GlobalInvocationID.xy), vec4(moments_curr, 1.0, 1.0));
        imageStore( gbuffers[next_sample_avg_addr],       ivec2(gl_GlobalInvocationID.xy), vec4(1));
        // imageStore( gbuffers[next_grad_addr],               ivec2(gl_GlobalInvocationID.xy), vec4(0));

        // imageStore( gbuffers[DEBUG_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(0));
    }
}
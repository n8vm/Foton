#version 460
#pragma optionNV (unroll all)

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

#define RADIUS 1
#define WIDTH (2 * RADIUS + 1) 

#if RADIUS == 1
const float h[3][3] = {
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
	{ 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
};
#endif

void main() {
    int in_tex_addr = int(push.consts.parameter1);
    int out_tex_addr = int(push.consts.parameter2);
    float radius = push.consts.parameter3;
    float cross_influence = 0;//clamp(push.consts.parameter3, 0, 1);
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    vec2 fpos = (vec2(ipos)) / (PATH_TRACE_TILE_SIZE * vec2(push.consts.width, push.consts.height));
    vec2 texelSize = vec2(1) / (PATH_TRACE_TILE_SIZE * vec2(push.consts.width, push.consts.height));
    ivec2 full_dims = ivec2(push.consts.width, push.consts.height);
   
    if (push.consts.iteration == 0) {
        int x,y;
        vec2 coords[WIDTH][WIDTH];
        for (y = -RADIUS; y <= RADIUS; ++y) {
            for (x = -RADIUS; x <= RADIUS; ++x) {
                coords[y+RADIUS][x+RADIUS] = get_filtered_uv(full_dims, fpos + texelSize * vec2(x,y) * radius);
            }
        }

        /* Normal weights */
        float norm_weights[WIDTH][WIDTH];
        vec3 norm_hires = imageLoad(gbuffers[NORMAL_ADDR], ipos).xyz;
        for (y = -RADIUS; y <= RADIUS; ++y) {
            for (x = -RADIUS; x <= RADIUS; ++x) {
                vec3 norm_coarse = texture( 
                        sampler2D(gbuffer_textures[COARSE_NORMAL_ADDR], samplers[LINEAR_SAMPLER]), 
                        coords[y+RADIUS][x+RADIUS]
                ).xyz;
                /* amplify dot-product for norm(x)norm_hires */
                norm_weights[y+RADIUS][x+RADIUS] = mix(pow(abs(dot(norm_coarse, norm_hires)), 16), 1, cross_influence);
            }
        }

        /* Depth weights */
        float depth_weights[WIDTH][WIDTH];
        vec4 pos_depth_hires = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
        for (y = -RADIUS; y <= RADIUS; ++y) {
            for (x = -RADIUS; x <= RADIUS; ++x) {
                vec4 pos_depth_coarse = texture( 
                        sampler2D(gbuffer_textures[COARSE_POSITION_DEPTH_ADDR], samplers[LINEAR_SAMPLER]), 
                        coords[y+RADIUS][x+RADIUS]
                );
                vec3 t = pos_depth_coarse.xyz - pos_depth_hires.xyz;
                float dist2 = dot(t, t) + t.z * t.z;
                depth_weights[y+RADIUS][x+RADIUS] = mix(min(exp(-(dist2)*.1), 1.0),1,cross_influence);//1.0f / (.0001 + abs(depth_hires - depth_coarse));
            }
        }

        /* Final color evaluation */
        vec4 color = vec4(0.0);
        float weight_sum = 0;
        for (y = -RADIUS; y <= RADIUS; ++y) {
            for (x = -RADIUS; x <= RADIUS; ++x) {
                float weight = norm_weights[y+RADIUS][x+RADIUS] * depth_weights[y+RADIUS][x+RADIUS] * h[y+RADIUS][x+RADIUS];
                color += texture( 
                        sampler2D(gbuffer_textures[in_tex_addr], samplers[LINEAR_SAMPLER]), 
                        coords[y+RADIUS][x+RADIUS]
                ) * weight;
                weight_sum += weight;
            }
        }
        color /= weight_sum;
        imageStore(gbuffers[out_tex_addr], ipos, color);
    } else {
        vec4 temp = imageLoad(gbuffers[out_tex_addr], ipos);
        imageStore(gbuffers[in_tex_addr], ipos, temp);
    }
}
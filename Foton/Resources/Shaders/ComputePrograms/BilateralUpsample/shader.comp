#version 460
#pragma optionNV (unroll all)

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

const vec2 g_kernel[4] = vec2[](
    vec2(0.0f, PATH_TRACE_TILE_SIZE),
    vec2(PATH_TRACE_TILE_SIZE, 0.0f),
    vec2(-PATH_TRACE_TILE_SIZE, 0.0f),
    vec2(0.0, -PATH_TRACE_TILE_SIZE)
);

void main() {
    int in_tex_addr = int(push.consts.parameter1);
    int out_tex_addr = int(push.consts.parameter2);
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    vec2 fpos = (vec2(ipos)) / (PATH_TRACE_TILE_SIZE * vec2(push.consts.width, push.consts.height));
    vec2 texelSize = vec2(1) / (PATH_TRACE_TILE_SIZE * vec2(push.consts.width, push.consts.height));
    
    if (push.consts.iteration == 0) {
        int i;
        vec2 coords[4];
        for (i = 0; i < 4; ++i) {
            coords[i] = fpos + texelSize * g_kernel[i];
        }

        /* Normal weights */
        float norm_weights[4];
        vec3 norm_hires = imageLoad(gbuffers[NORMAL_ADDR], ipos).xyz;
        for (i = 0; i < 4; ++i) {
            vec3 norm_coarse = texture( 
                    sampler2D(gbuffer_textures[COARSE_NORMAL_ADDR], samplers[LINEAR_SAMPLER]), 
                    coords[i]
            ).xyz;
            /* amplify dot-product for norm(x)norm_hires */
            norm_weights[i] = pow(abs(dot(norm_coarse, norm_hires)), 128);
        }

        /* Depth weights */
        float depth_weights[4];
        vec4 pos_depth_hires = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
        for (i = 0; i < 4; ++i) {
            vec4 pos_depth_coarse = texture( 
                    sampler2D(gbuffer_textures[COARSE_POSITION_DEPTH_ADDR], samplers[LINEAR_SAMPLER]), 
                    coords[i]
            );
            vec3 t = pos_depth_coarse.xyz - pos_depth_hires.xyz;
            float dist2 = dot(t, t) + t.z * t.z;
            depth_weights[i] = min(exp(-(dist2)*.1), 1.0);//1.0f / (.0001 + abs(depth_hires - depth_coarse));
        }

        /* Final color evaluation */
        vec4 color = vec4(0.0);
        float weight_sum = 0;
        for (i = 0; i < 4; ++i) {
            float weight = norm_weights[i] * depth_weights[i];
            color += texture( 
                    sampler2D(gbuffer_textures[in_tex_addr], samplers[LINEAR_SAMPLER]), 
                    coords[i]
            ) * weight;
            weight_sum += weight;
        }
        color /= weight_sum;
        imageStore(gbuffers[out_tex_addr], ipos, color);
    } else {
        vec4 temp = imageLoad(gbuffers[out_tex_addr], ipos);
        imageStore(gbuffers[in_tex_addr], ipos, temp);
    }
}
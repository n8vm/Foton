#version 460
#pragma optionNV (unroll all)

/* Denoises raw color data before being fed into the geometric TAA */

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

#define RADIUS 1

#if RADIUS == 2
const float h[5][5] = {
    {1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0},
    {1.0/64.0,  1.0/16.0, 3.0/32.0,  1.0/16.0, 1.0/64.0},
    {3.0/128.0, 3.0/32.0, 9.0/64.0,  3.0/32.0, 3.0/128.0},
    {1.0/64.0,  1.0/16.0, 3.0/32.0,  1.0/16.0, 1.0/64.0},
    {1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0}
};
#endif

#if RADIUS == 1
const float h[3][3] = {
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
	{ 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
};
#endif

#define GAUSS_RADIUS 1
const float gaussKernel[9] = float[9](1.0/16.0, 1.0/8.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/8.0, 1.0/16.0, 1.0/8.0, 1.0/16.0);
const float gaussian_kernel[3][3] = {
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
	{ 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
};

bool eps_equal(float a, float b){
  return round(a) == round(b);
}

float
compute_sigma_luminance(float center, ivec2 ipos, int addr)
{
	const int r = GAUSS_RADIUS;

	float sum = center * gaussian_kernel[0][0];

	for(int yy = -r; yy <= r; yy++) {
		for(int xx = -r; xx <= r; xx++) {
			if(xx != 0 || yy != 0) {
				ivec2 p = ipos + ivec2(xx, yy);
				float v = imageLoad(gbuffers[addr], p).a; // POSSIBLE BUG HERE...
				float w = gaussian_kernel[xx + 1][yy + 1];
				sum += v * w;
			}
		}
	}

	return sqrt(max(sum, 0.0));
}

void main() {
    bool upsampling = false;//is_bilateral_upsampling_enabled();
    if (upsampling) {
        if (int(gl_GlobalInvocationID.x) >= push.consts.width) return;
        if (int(gl_GlobalInvocationID.y) >= push.consts.height) return;
    }
    else {
        if (int(gl_GlobalInvocationID.x * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
        if (int(gl_GlobalInvocationID.y * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;
    }

    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 ipos_full = ivec2(gl_GlobalInvocationID.xy) * (upsampling ? 1 : PATH_TRACE_TILE_SIZE) ;
    int minor_iteration = push.consts.iteration % 2;
    int major_iteration = push.consts.iteration;

    const int d_addr_0 = ((minor_iteration%2) != 0) ? GLOSSY_DIRECT_ADDR : ATROUS_HISTORY_1_ADDR;
    const int d_addr_1 = ((minor_iteration%2) != 0) ? ATROUS_HISTORY_1_ADDR : GLOSSY_DIRECT_ADDR;
    const int i_addr_0 = ((minor_iteration%2) != 0) ? GLOSSY_INDIRECT_ADDR : ATROUS_HISTORY_2_ADDR;
    const int i_addr_1 = ((minor_iteration%2) != 0) ? ATROUS_HISTORY_2_ADDR : GLOSSY_INDIRECT_ADDR;

    vec4 p_pos_dep_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos_full);
    vec4 p_norm_data = imageLoad(gbuffers[NORMAL_ADDR], ipos_full);
    vec4 p_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full);
    vec4 p_lum_var_data = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR], ipos);
    vec4 p_uv_met_rough = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR],  ipos_full);
    vec4 p_direct_var = imageLoad(gbuffers[d_addr_0], ipos);
    vec4 p_indirect_var = imageLoad(gbuffers[i_addr_0], ipos);  
    vec4 p_spec_axis_sharpness = imageLoad(gbuffers[LOBE_AXIS_SHARPNESS_ADDR], ipos_full); 
    float l_p_direct = luminance(p_direct_var.rgb);
    float l_p_indirect = luminance(p_indirect_var.rgb);

    float screen_correction = max(push.consts.width, push.consts.height) / (upsampling ? 1 : PATH_TRACE_TILE_SIZE);

    int curr_step_width = 1 << major_iteration;
    // float l_sigma_direct = compute_sigma_luminance(p_direct_var.a, ipos, d_addr_0) * 3.0 * push.consts.parameter1; 
    // float l_sigma_indirect = compute_sigma_luminance(p_indirect_var.a, ipos, i_addr_0) * 3.0 * push.consts.parameter2; 
    // float r_sigma_direct =  push.consts.parameter1;//11.9;//(1.0 - pow(push.consts.parameter1, .1)) * screen_correction; // user controllable power
    // float r_sigma_indirect =  push.consts.parameter2;//11.9;//(1.0 - pow(push.consts.parameter2, .1)) * screen_correction; // user controllable power


    float p_sigma_direct = 1. * (1.0 - pow(push.consts.parameter1, .01)) * screen_correction; 
    float p_sigma_indirect = 1.0 * (1.0 - pow(push.consts.parameter2, .01)) * screen_correction; 
    float r_sigma_direct = clamp(push.consts.parameter1, 0, .99);
    float r_sigma_indirect = clamp(push.consts.parameter2, 0, .99);
    
    p_sigma_direct = ((major_iteration+1) * p_sigma_direct);
    p_sigma_indirect = ((major_iteration+1) * p_sigma_indirect);
    
    vec3 sum_direct = vec3(0.0);
    vec3 sum_indirect = vec3(0.0);
    float sum_var_direct = EPSILON;
    float sum_var_indirect = EPSILON;
    float weights_direct = EPSILON;
    float weights_indirect = EPSILON;

    if (int(p_id_data.r) != -1) {
        for (int yy = -RADIUS; yy <= RADIUS; ++yy){
            for (int xx = -RADIUS; xx <= RADIUS; ++xx) {
                ivec2 offset = ivec2(xx, yy) * curr_step_width;
                ivec2 st = ipos + offset;
                ivec2 st_full = st * (upsampling ? 1 : PATH_TRACE_TILE_SIZE);
                if ((st.x < 0) || (st.y < 0) || 
                    (st.x >= push.consts.width) 
                    || (st.y >= push.consts.height)) continue;

                vec4 q_direct_var = imageLoad(gbuffers[d_addr_0], ivec2(st));
                vec4 q_indirect_var = imageLoad(gbuffers[i_addr_0], ivec2(st));
                vec4 q_norm_data = imageLoad(gbuffers[NORMAL_ADDR], st_full);
                vec4 q_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], st_full);
                if (any(isnan(q_direct_var))) continue; 
                if (any(isnan(q_indirect_var))) continue;
                if (!eps_equal(p_id_data.r, q_id_data.r)) continue;
                vec4 q_pos_dep_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], st_full);

                vec3 t = p_pos_dep_data.xyz - q_pos_dep_data.xyz;
                float dist2 = dot(t, t) + t.z * t.z;
                float l_q_direct = luminance(q_direct_var.rgb);
                float l_q_indirect = luminance(q_indirect_var.rgb);
                float wp_direct = min(exp(-(dist2)*p_sigma_direct), 1.0);
                float wp_indirect = min(exp(-(dist2)*p_sigma_indirect), 1.0);
                float wn = 1;//pow(max(0.0, dot(p_norm_id_data.xyz, q_norm_id_data.xyz)), n_sigma);

                /* Specular Aware Spherical Gaussian Weight */


                // not sure what to set these to...
                float beta_direct = (1.0 - r_sigma_direct) * 300;
                float beta_indirect = (1.0 - r_sigma_indirect) * 500;
                
                // lobe sharpness
                vec4 temp = imageLoad(gbuffers[LOBE_AXIS_SHARPNESS_ADDR], st_full);
                float lambda_q = temp.w;
                float lambda_p = p_spec_axis_sharpness.w;
                                
                // lobe axis
                vec3 xi_q = temp.xyz;
                vec3 xi_p = p_spec_axis_sharpness.xyz;

                float direct_lobe_axis_similarity = exp((beta_direct*lambda_p*lambda_q)/(lambda_p + lambda_q) * (pow(dot(xi_p,xi_q), beta_direct) - 1.0f));
                // float direct_lobe_axis_similarity = exp((beta_direct*lambda_p*lambda_q)/(lambda_p + lambda_q) * ((dot(xi_p,xi_q) * beta_direct * .01) - 1.0f));
                float direct_lobe_sharpness_similarity = pow( (2.0 * sqrt(lambda_p * lambda_q)) / (lambda_p + lambda_q), beta_direct);
                float wr_direct = direct_lobe_axis_similarity * direct_lobe_sharpness_similarity;

                float indirect_lobe_axis_similarity = exp((beta_indirect*lambda_p*lambda_q)/(lambda_p + lambda_q) * (pow(dot(xi_p,xi_q), beta_indirect) - 1.0f));
                // float indirect_lobe_axis_similarity = exp((beta_indirect*lambda_p*lambda_q)/(lambda_p + lambda_q) * ((dot(xi_p,xi_q) * beta_indirect * .01) - 1.0f));
                float indirect_lobe_sharpness_similarity = pow( (2.0 * sqrt(lambda_p * lambda_q)) / (lambda_p + lambda_q), beta_indirect);
                float wr_indirect = indirect_lobe_axis_similarity * indirect_lobe_sharpness_similarity;
                           


                // float gvl = 0.001;
                // for (int y0 = -GAUSS_RADIUS; y0 <= GAUSS_RADIUS; y0++) {
                //     for (int x0 = -GAUSS_RADIUS; x0 <= GAUSS_RADIUS; x0++) {
                //         gvl += gaussian_kernel[yy + GAUSS_RADIUS][xx + GAUSS_RADIUS] * imageLoad(gbuffers[d_addr_0], ivec2(st) + ivec2(x0, y0)).a;
                //     }
                // }
                // float wl = min(1.0, exp(-abs(l_p - l_q) / (l_sigma * sqrt(gvl) + EPSILON)));


                // float wl = clamp(abs(l_q - l_p) / (l_sigma + 1e-10), 0.0, 1.0); 
                float wl_direct = wr_direct; //*clamp(exp(-abs(l_p_direct - l_q_direct) / (l_sigma_direct + 1e-10)), 0.0, 1.0); 
                float wl_indirect = wr_indirect; //*clamp(exp(-abs(l_p_indirect - l_q_indirect) / (l_sigma_indirect + 1e-10)), 0.0, 1.0); 
                if (isnan(l_q_direct)) continue;
                if (isnan(l_q_indirect)) continue;
                if (isnan(l_p_direct)) continue;
                if (isnan(l_p_indirect)) continue;

                /* Force no blur if these parameters are 0 (kludge for now) */
                // wl_direct = ((xx == 0) && (yy == 0)) ? r_sigma_direct : 0.0;
                // wl_indirect = ((xx == 0) && (yy == 0)) ? r_sigma_indirect : 0.0;
                
                // if (isnan(l_sigma_direct)) continue;
                // if (isnan(l_sigma_indirect)) continue;

                // float wl = abs(l_q - l_p) / (l_sigma + 1e-10); 
                // float wl = ((xx != 0) && (yy != 0)) ? max(1.0 - l_sigma, 0.0) : 1;
                // float wl = 1.0;

                
                // position weight here doesn't seem right...
                float w_direct = /*wp_direct * */wl_direct;
                float w_indirect = /*wp_indirect **/ wl_indirect;
                float weight_direct = h[yy + RADIUS][xx + RADIUS] * w_direct;
                float weight_indirect = h[yy + RADIUS][xx + RADIUS] * w_indirect;

                sum_direct += weight_direct * q_direct_var.rgb;
                sum_indirect += weight_indirect * q_indirect_var.rgb;
                sum_var_direct += weight_direct * weight_direct * q_direct_var.w;
                sum_var_indirect += weight_indirect * weight_indirect * q_indirect_var.w;
                weights_direct += weight_direct;
                weights_indirect += weight_indirect;
            }
        }

        vec3 direct_result;
        vec3 indirect_result;
        float direct_var_result;
        float indirect_var_result;
        if (weights_direct > EPSILON) {
            direct_var_result = sum_var_direct/weights_direct;
            float alpha = 0.0;//exp(-p_samples);//1.0 - clamp(var_result, 0.0, 1.0); //min(max(uv_metallic_roughness.z, (1.0 - uv_metallic_roughness.w)), 1.0); // note, num_samples is normalized
            direct_result = (alpha * p_direct_var.rgb) + ((1.0 - alpha) * (sum_direct/weights_direct));
        } else {
            direct_result = p_direct_var.rgb;
            direct_var_result = p_direct_var.w;
        }
        if (weights_indirect > EPSILON) {
            indirect_var_result = sum_var_indirect/weights_indirect;
            float alpha = 0.0;//exp(-p_samples);//1.0 - clamp(var_result, 0.0, 1.0); //min(max(uv_metallic_roughness.z, (1.0 - uv_metallic_roughness.w)), 1.0); // note, num_samples is normalized
            indirect_result = (alpha * p_indirect_var.rgb) + ((1.0 - alpha) * (sum_indirect/weights_indirect));
        } else {
            indirect_result = p_indirect_var.rgb;
            indirect_var_result = p_indirect_var.w;
        }

        /* Cant seem to get this to work yet*/

        // direct_result = clamp(direct_result, 0.0, 10.0);
        // indirect_result = clamp(indirect_result, 0.0, 10.0);
        if (any(isnan(direct_result))) direct_result = vec3(0.);
        if (any(isnan(indirect_result))) indirect_result = vec3(0.);
        if (isnan(direct_var_result)) direct_var_result = 1.;
        if (isinf(direct_var_result)) direct_var_result = 1.;
        if (isnan(indirect_var_result)) indirect_var_result = 1.;
        if (isinf(indirect_var_result)) indirect_var_result = 1.;
        
        /* denoising direct specular this way looks really bad... */
        // if (major_iteration < 2) {
        imageStore(gbuffers[d_addr_1], ipos, vec4(direct_result.rgb, direct_var_result));
        // }

        /* denoising direct this way also looks pretty bad... */
        imageStore(gbuffers[i_addr_1], ipos, vec4(indirect_result.rgb, indirect_var_result));
    }
}

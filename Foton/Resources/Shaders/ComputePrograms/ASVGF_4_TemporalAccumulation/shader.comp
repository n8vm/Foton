#version 460
#pragma optionNV (unroll all)

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

// Tends to blur out details, but makes convergence more stable
#define RADIUS 2

#if RADIUS == 2
float Coefficients[25] = 
{
    0.000002,	0.000212,	0.000922,	0.000212,	0.000002,
    0.000212,	0.024745,	0.107391,	0.024745,	0.000212,
    0.000922,	0.107391,	0.466066,	0.107391,	0.000922,
    0.000212,	0.024745,	0.107391,	0.024745,	0.000212,
    0.000002,	0.000212,	0.000922,	0.000212,	0.000002,
};
#endif

// sigma .20
#if RADIUS == 1
float Coefficients[9] = 
{
    0.000039,	0.006133,	0.000039,
    0.006133,	0.975316,	0.006133,
    0.000039,	0.006133,	0.000039,
};
#endif

#if RADIUS == 0
float Coefficients[1] = {
    1.0
};
#endif

void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    float gradient_weight = push.consts.parameter1;

    // This temporal accumulation uses two ping pong buffers per accumulated
    // g buffer. These are the current and next gbuffer addreses for each.
    const int curr_direct_hist_addr   = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_1_ADDR : SVGF_TAA_HISTORY_2_ADDR;
    const int next_direct_hist_addr   = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_2_ADDR : SVGF_TAA_HISTORY_1_ADDR;
    const int curr_indirect_hist_addr = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_3_ADDR : SVGF_TAA_HISTORY_4_ADDR;
    const int next_indirect_hist_addr = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_4_ADDR : SVGF_TAA_HISTORY_3_ADDR;
    const int curr_moments_addr       = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_5_ADDR : SVGF_TAA_HISTORY_6_ADDR;
    const int next_moments_addr       = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_6_ADDR : SVGF_TAA_HISTORY_5_ADDR;
    const int curr_sample_count_addr  = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_7_ADDR : SVGF_TAA_HISTORY_8_ADDR;
    const int next_sample_count_addr  = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_8_ADDR : SVGF_TAA_HISTORY_7_ADDR;
    const int curr_grad_addr  = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_9_ADDR : SVGF_TAA_HISTORY_10_ADDR;
    const int next_grad_addr  = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_10_ADDR : SVGF_TAA_HISTORY_9_ADDR;

    // Compute motion vector
    // Note, the w component indicates an invalid motion vector, which can 
    // occur for pixels containing the background
    bool reset = false;
    precise vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos);
    if (motion_data.w > 0) reset = true; // reset history if motion data is invalid
    precise vec2 v = motion_data.xy * vec2(.5, -.5);
    precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
    iv.x = (abs(iv.x) < MOTION_VECTOR_MIN) ? 0 : iv.x;
    iv.y = (abs(iv.y) < MOTION_VECTOR_MIN) ? 0 : iv.y;
    ivec2 pos_prev = ivec2(ipos + iv + MOTION_VECTOR_OFFSET);
    ivec2 p = ivec2(pos_prev - 0.5);

    // Load g buffer data which we'll use for detecting disocclusions
    vec4 curr_albedo_data = imageLoad(gbuffers[ALBEDO_ADDR], ipos);
    vec4 curr_normal_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos);
    vec4 curr_position_depth_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    int samples = int(imageLoad(gbuffers[curr_sample_count_addr], ipos).r);

    // vec4 curr_uv_metallic_roughness_data = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR], ipos);
    vec3 curr_albedo = curr_albedo_data.rgb;
    int curr_entity_id = int(curr_normal_id_data.a);
    vec3 curr_pos = curr_position_depth_data.xyz;
    float z_curr = curr_position_depth_data.w;
    // float metallic = curr_uv_metallic_roughness_data.z;
    // float roughness = curr_uv_metallic_roughness_data.w;

    // Load g buffer data to be temporally accumulated
	vec4  direct_curr     = imageLoad(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], ipos);
	vec4  indirect_curr   = imageLoad(gbuffers[SPECULAR_ILLUM_VAR_ADDR], ipos);
	vec2  moments_curr = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR], ipos).rg;
    // vec4  grad_curr = imageLoad(gbuffers[TEMPORAL_GRADIENT_ADDR], ipos); 

    // We'll be estimating these values by a simple filter surrounding the reprojected position
    vec4 direct_prev  = vec4(0);
    vec4 indirect_prev  = vec4(0);
    float antilag_prev = 0;
    vec4 hist_prev    = vec4(0);
	vec2 moments_prev = vec2(0);
	float sum_w       = 0.0;
	float histlen     = 0.0;
    if (!reset) {
        const int max_rad = 1;// * PATH_TRACE_TILE_SIZE;
	    const float hist_len_thresh = max_rad + MIN_SAMPLES;
        float alpha = (hist_len_thresh - clamp(samples, 0, hist_len_thresh) ) / hist_len_thresh;
        const int r = int(mix(1, max_rad, alpha));
        for (int y = -r; y <= r; ++y) {
            for (int x = -r; x <= r; ++x) {
                ivec2 ipos_prev = pos_prev + ivec2(x, y);
                
                // Load disocclusion gbuffer data
                vec4 hist_albedo_data = imageLoad(gbuffers[ALBEDO_ADDR_PREV], ipos_prev);
                vec4 hist_normal_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR_PREV], ipos_prev);
                vec4 hist_pos_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR_PREV], ipos_prev);
                
                vec3 hist_albedo = hist_albedo_data.rgb;
                int hist_entity_id = int(hist_normal_id_data.a);
                vec3 hist_pos = hist_pos_data.xyz;
                float hist_dist = hist_pos_data.w;
                
                // Load prior gbuffer data to accumulate temporally 
                vec4 direct = imageLoad(gbuffers[curr_direct_hist_addr], ipos_prev);
                vec4 indirect = imageLoad(gbuffers[curr_indirect_hist_addr], ipos_prev);
                vec2 moments = imageLoad(gbuffers[curr_moments_addr], ipos_prev).rg;
                int samples = int(imageLoad(gbuffers[curr_sample_count_addr], ipos_prev).r);
                vec4 luminance_data = imageLoad(gbuffers[curr_moments_addr], ipos_prev);
                // vec4 grad = imageLoad(gbuffers[curr_grad_addr], ipos_prev);
                float antilag = imageLoad(gbuffers[curr_grad_addr], ipos_prev).r;

                bvec2 a = greaterThan(ipos_prev, vec2(push.consts.width-1, push.consts.height-1));
                bvec2 b = lessThan(ipos_prev, vec2(0.0, 0.0));
                
                // Determine if this prior sample is a disocclusion. If not, accept it.
                bool accept = true;
                accept = accept && (!any(bvec2(any(a), any(b))));
                accept = accept && (!any(isnan(direct)));
                accept = accept && (!any(isinf(direct)));
                accept = accept && (!any(isnan(indirect)));
                accept = accept && (!any(isinf(indirect)));
                accept = accept && (!any(isnan(moments)));
                accept = accept && (!any(isinf(moments)));
                accept = accept && (!isnan(antilag));
                accept = accept && (!isinf(antilag));

                // accept = accept && (!any(isnan(gradient_data)));
                // accept = accept && (!any(isinf(gradient_data)));                
                accept = accept && (hist_entity_id == curr_entity_id);

                /* Some of these seem to lead to unneccesary history resets */
                // accept = accept && (distance(hist_albedo,  curr_albedo) < ALBEDO_MAX);
                // accept = accept && (dot(hist_normal_id_data.rgb, curr_normal_id_data.rgb) > 0.0);
                // accept = accept && (abs(hist_dist - z_curr) < POSITION_MAX);
                // accept = accept && (distance(hist_pos,  curr_pos) < DISTANCE_MAX);

                if (accept) {
                    float w = 1.;
                    direct_prev += direct * w;
                    indirect_prev += indirect * w;
                    moments_prev += moments * w;
                    antilag_prev += antilag * w;
                    histlen      += samples * w;
                    sum_w        += w;
                }
            }
        }
    }

    // Compute the antilag alpha based off of temporal gradient
    float antilag_alpha = 0.0;
    float avg_max_lum = 0.0;
    if (is_gradient_estimation_enabled())
	{
		const int r = GRADIENT_FILTER_RADIUS;
        float w_sum = 0.f;
		for(int y = -r; y <= r; y++) {
			for(int x = -r; x <= r; x++) {
				vec2 gradient_max_luminance = imageLoad(gbuffers[TEMPORAL_GRADIENT_ADDR], pos_prev + ivec2(x, y) * GRADIENT_TILE_SIZE).rg; 
				// float avg_lum = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR_PREV], pos_prev + ivec2(x, y) * PATH_TRACE_TILE_SIZE).r; 
                float max_l = gradient_max_luminance.r;
                float gradient = gradient_max_luminance.g;
				// float a = clamp(abs(max_l > 1e-4 ? abs(gradient) / max_l : 0.0), 0.0, 200.0);
				float a = /*clamp(*/ abs(max_l > 1e-4 ? abs(gradient) / max_l : 0.0);//, 0.0, 2000.0);
				float w = 1.0 / float((2 * r + 1) * (2 * r + 1));
				antilag_alpha = max(antilag_alpha, a);
                // avg_max_lum += max_l;
				// antilag_alpha += a * w;
                // w_sum += 1;
			}
		}
        // avg_max_lum /= w_sum;
        // antilag_alpha /= w_sum;

        clamp(antilag_alpha, 0.0, 1.0);
        if(isnan(antilag_alpha))
            antilag_alpha = 0.0;

        antilag_alpha = pow(antilag_alpha, gradient_weight); // testing
        // antilag_alpha *= gradient_weight;
        // if (antilag_alpha < .5) antilag_alpha = 0; //testing
	}

    if (sum_w > 0.01) { /* found sufficiently reliable history information */
        direct_prev   /= sum_w;
        indirect_prev /= sum_w;
		moments_prev  /= sum_w;
		antilag_prev  /= sum_w;
		histlen       /= sum_w;

        float accum_antilag = mix(antilag_prev, antilag_alpha, GRADIENT_ALPHA);

        float alpha_color   = max(1.0 / MAX_CUMULATIVE_COUNT, 1.0 / (histlen + 1.0));
		float alpha_moments = max(0.6, 1.0 / (histlen + 1.0));

        alpha_color   = mix(alpha_color,   (1.0 / MAX_CUMULATIVE_COUNT) * 10.0, accum_antilag);
		alpha_moments = mix(alpha_moments, (1.0 / MAX_CUMULATIVE_COUNT) * 10.0, accum_antilag);
		vec2 accum_moments = mix(moments_prev, moments_curr, alpha_moments);
        
        float variance = abs(accum_moments.y - accum_moments.x * accum_moments.x);  

        





		float color_count   = clamp(histlen, MIN_SAMPLES, MAX_CUMULATIVE_COUNT);
        float moments_count = clamp(histlen, MIN_SAMPLES, MAX_CUMULATIVE_COUNT);

        
        // I don't know why, but mix seems to lose precision... always seems to reduce alpha color. 
		// alpha_color   = mix(alpha_color,   1.0, accum_antilag); 
        color_count = mix(color_count, 1.0, clamp(accum_antilag, 0.0, 1.0));
		moments_count = mix(moments_count, 1.0, clamp(accum_antilag, 0.0, 1.0));
		
        // float accum_a = min(MAX_CUMULATIVE_COUNT, histlen);
        float accum_histlen = color_count + 1.0;
	// vec2 accum_moments = mix(moments_prev, moments_curr, 1.0 / moments_count);
        // if (moments_count <= 1) accum_moments.y = 1;
        
    // float variance = abs(accum_moments.y - accum_moments.x * accum_moments.x);
        if (isnan(variance) ) variance = 200;
        // vec4 accum_direct = vec4(mix(direct_prev.rgb, direct_curr.rgb, 1.0 / color_count), variance);
        // vec4 accum_indirect = vec4(mix(indirect_prev.rgb, indirect_curr.rgb, 1.0 / color_count), accum_histlen);


        vec4 accum_direct = vec4(mix(direct_prev.rgb, direct_curr.rgb, alpha_color), variance);
        vec4 accum_indirect = vec4(mix(indirect_prev.rgb, indirect_curr.rgb, alpha_color), accum_histlen);
        

        imageStore( gbuffers[DIFFUSE_ILLUM_VAR_ADDR],        ivec2(gl_GlobalInvocationID.xy), accum_direct);
        imageStore( gbuffers[SPECULAR_ILLUM_VAR_ADDR],      ivec2(gl_GlobalInvocationID.xy), accum_indirect);
        imageStore( gbuffers[LUMINANCE_VARIANCE_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(accum_moments, z_curr, accum_histlen));
        imageStore( gbuffers[SAMPLE_COUNT_ADDR],            ivec2(gl_GlobalInvocationID.xy), vec4(accum_histlen));
        imageStore( gbuffers[VARIANCE_ADDR],                ivec2(gl_GlobalInvocationID.xy), vec4(variance));
        // imageStore( gbuffers[TEMPORAL_GRADIENT_ADDR],       ivec2(gl_GlobalInvocationID.xy), vec4(accum_antilag));

        imageStore( gbuffers[next_direct_hist_addr],        ivec2(gl_GlobalInvocationID.xy), accum_direct );
        imageStore( gbuffers[next_indirect_hist_addr],      ivec2(gl_GlobalInvocationID.xy), accum_indirect);
        imageStore( gbuffers[next_moments_addr],            ivec2(gl_GlobalInvocationID.xy), vec4(accum_moments, z_curr, z_curr));
        imageStore( gbuffers[next_sample_count_addr],       ivec2(gl_GlobalInvocationID.xy), vec4(accum_histlen));
        imageStore( gbuffers[next_grad_addr],       ivec2(gl_GlobalInvocationID.xy), vec4(accum_antilag));

        // imageStore( gbuffers[DEBUG_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(abs(accum_antilag)));
    } else {
        /* encodes variance */
        direct_curr.w = 200;
        indirect_curr.w = 200;

        imageStore( gbuffers[DIFFUSE_ILLUM_VAR_ADDR],        ivec2(gl_GlobalInvocationID.xy), direct_curr);
        imageStore( gbuffers[SPECULAR_ILLUM_VAR_ADDR],      ivec2(gl_GlobalInvocationID.xy), indirect_curr);
        imageStore( gbuffers[LUMINANCE_VARIANCE_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(moments_curr, z_curr, z_curr));
        imageStore( gbuffers[SAMPLE_COUNT_ADDR],            ivec2(gl_GlobalInvocationID.xy), vec4(1));
        imageStore( gbuffers[VARIANCE_ADDR],                ivec2(gl_GlobalInvocationID.xy), vec4(200));
        imageStore( gbuffers[next_direct_hist_addr],        ivec2(gl_GlobalInvocationID.xy), direct_curr);
        imageStore( gbuffers[next_indirect_hist_addr],      ivec2(gl_GlobalInvocationID.xy), indirect_curr);
        imageStore( gbuffers[next_moments_addr],            ivec2(gl_GlobalInvocationID.xy), vec4(moments_curr, z_curr, z_curr));
        imageStore( gbuffers[next_sample_count_addr],       ivec2(gl_GlobalInvocationID.xy), vec4(1));
        imageStore( gbuffers[next_grad_addr],               ivec2(gl_GlobalInvocationID.xy), vec4(0));

        // imageStore( gbuffers[DEBUG_ADDR],      ivec2(gl_GlobalInvocationID.xy), vec4(0));
    }
}
#version 460
// We're interested in computing the temporal gradient for the current frame i
// at a forward projected pixel location j.

// This cam be computed by taking the difference between two shading sample 
// functions, f_[i] - f_[i-1]

// This shading sample function is parameterized by a surface sample G and a 
// random seed S

// Specificly, the current shading sample function f_[i] is parameterized by the
// surface sample G from the frame i-1, forward projected to the current frame
// using motion vectors. It's parameterized by a seed as well, which is 
// forward projected to the current frame.

// The previous shading sample function f_[i-1] is parameterized by the surface 
// sample G from the frame i-1 (not forward projected), and by the seed from 
// the previous frame i-1 (also not forward projected). The result of this 
// shading sample function is the sample from the previous frame.

// Note that only a subset of the previous samples satisfy the above criteria.
// specifically, only a subset use reprojected samples.

// In practice, we only care about the luminance of the sample from the previous
// frame, which is stored alongside the seed.

#define COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Random.hxx"
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

void main() {
    // Stride of the gradient tile
    const int stride = GRADIENT_TILE_SIZE;
    if (int(gl_GlobalInvocationID.x * stride) >= push.consts.width) return;
    if (int(gl_GlobalInvocationID.y * stride) >= push.consts.height) return;

    // Compute random offset within tile
    init_random(ivec2(gl_GlobalInvocationID.xy), push.consts.frame, 0);
    int rand_curr = int(random() * stride * stride);
    ivec2 tile = ivec2(gl_GlobalInvocationID.xy);
    ivec2 offset_curr = ivec2(rand_curr / stride, rand_curr % stride);

    // Compute motion vector
    ivec2 ipos = (stride * tile + offset_curr);
    precise vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos);
    precise vec2 v = motion_data.xy * vec2(.5, -.5);
    precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
    iv.x = (abs(iv.x) < MOTION_VECTOR_MIN) ? 0 : iv.x;
    iv.y = (abs(iv.y) < MOTION_VECTOR_MIN) ? 0 : iv.y;
    ivec2 ipos_prev = ivec2(ipos + (iv + MOTION_VECTOR_OFFSET));

    // Detect if the current pixel was rendered as a gradient sample
    // Note: A pixel is a reprojected seed if all seed values match
    vec4 curr_seed = imageLoad(gbuffers[SEED_LUMINANCE_ADDR], ipos);
    vec4 prev_seed = imageLoad(gbuffers[SEED_LUMINANCE_ADDR_PREV], ipos_prev);
    vec4 curr_luminance = imageLoad(gbuffers[LUMINANCE_ADDR], ipos);
    vec4 prev_luminance = imageLoad(gbuffers[LUMINANCE_ADDR_PREV], ipos_prev);
    vec4 prev_id = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos);
    vec4 curr_id = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR_PREV], ipos_prev);
    bool is_reproj_grad = all(equal(prev_seed.xyz, curr_seed.xyz)) && (int(prev_id.r) == int(curr_id.r));

    // Compute the temporal gradient and max luminance
    vec4 l_prev = any(isnan(prev_luminance)) ? vec4(0.0) : prev_luminance;
    vec4 l_curr = any(isnan(curr_luminance)) ? vec4(0.0) : curr_luminance;
    vec4 temporal_gradient = (is_reproj_grad) ? abs(l_curr - l_prev) : vec4(0.0);
    vec4 max_luminance = max(l_curr, l_prev);

    // Compute first and second moments over the tile
    int mesh_id = int(curr_id.r);
    vec4 first_moment = vec4(l_curr);
    vec4 second_moment = vec4(l_curr * l_curr);
    float sum_w = 1.0;
    for (int y = 0; y < stride; y++) {
        for (int x = 0; x < stride; x++) {
            ivec2 p = stride * tile + ivec2(x,y);
            // skip the center pixel, we already account for it.
            if(all(equal(ipos, p))) continue;
            
            vec4 pixel_luminance = imageLoad(gbuffers[LUMINANCE_ADDR], p);
            vec4 pixel_id      = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR_PREV], p);
            int mesh_id_p = int(pixel_id.r);
            
            // ignore luminance values which belong to different objects
            float w = mesh_id_p == mesh_id ? 1.0 : 0.0;
            vec4 l = any(isnan(pixel_luminance)) ? vec4(0.0) : pixel_luminance;
            first_moment += (l*w);
            second_moment += (l*l*w);
            sum_w += w;
        }
    }
    first_moment /= sum_w;
    second_moment /= sum_w;

    // Compute variance (second moment minus first moment squared)
    vec4 variance = abs(second_moment - first_moment * first_moment);
    if (any(isnan(variance))) variance = vec4(200);

    /* BAD. FOR NOW, REPLICATE RESULTS */
    // vec4 max_lum_grad = vec4(max_luminance, temporal_gradient, 1.0, 0.0);
    // vec4 avg_lum_variance = vec4(moments[0], variance, z_curr, z_curr);
    for (int y = 0; y < stride; y++) {
        for (int x = 0; x < stride; x++) {
            imageStore(gbuffers[TEMPORAL_GRADIENT_ADDR], stride * tile + ivec2(x,y), temporal_gradient);
            imageStore(gbuffers[LUMINANCE_AVERAGE_ADDR], stride * tile + ivec2(x,y), first_moment);
            imageStore(gbuffers[LUMINANCE_VARIANCE_ADDR], stride * tile + ivec2(x,y), variance);
            imageStore(gbuffers[LUMINANCE_MAX_ADDR], stride * tile + ivec2(x,y), max_luminance);
        }
    }
}
#version 460
// We're interested in computing the temporal gradient for the current frame i
// at a forward projected pixel location j.

// This cam be computed by taking the difference between two shading sample 
// functions, f_[i] - f_[i-1]

// This shading sample function is parameterized by a surface sample G and a 
// random seed S

// Specificly, the current shading sample function f_[i] is parameterized by the
// surface sample G from the frame i-1, forward projected to the current frame
// using motion vectors. It's parameterized by a seed as well, which is 
// forward projected to the current frame.

// The previous shading sample function f_[i-1] is parameterized by the surface 
// sample G from the frame i-1 (not forward projected), and by the seed from 
// the previous frame i-1 (also not forward projected). The result of this 
// shading sample function is the sample from the previous frame.

// Note that only a subset of the previous samples satisfy the above criteria.
// specifically, only a subset use reprojected samples.

// In practice, we only care about the luminance of the sample from the previous
// frame, which is stored alongside the seed.

#define CAMERA_COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Foton/Resources/Shaders/Common/Random.hxx"
#include "Foton/Resources/Shaders/Common/ShaderCommon.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

#define PRECOMPUTE_MOMENTS true

void main() {
    if (int(gl_GlobalInvocationID.x * GRADIENT_TILE_SIZE * PATH_TRACE_TILE_SIZE) >= push.consts.width) return;
    if (int(gl_GlobalInvocationID.y * GRADIENT_TILE_SIZE * PATH_TRACE_TILE_SIZE) >= push.consts.height) return;

    // Compute random offset within tile
    int rand_curr;
    // if (GRADIENT_USE_RANDOM) {
    //     init_random(ivec2(gl_GlobalInvocationID.xy), push.consts.frame, 0);
    //     rand_curr = int(random() * GRADIENT_TILE_SIZE * GRADIENT_TILE_SIZE);
    // } else {
    // }
    rand_curr = push.consts.frame % (GRADIENT_TILE_SIZE * GRADIENT_TILE_SIZE);
    ivec2 tile = ivec2(gl_GlobalInvocationID.xy);
    ivec2 offset_curr = ivec2(rand_curr / GRADIENT_TILE_SIZE, rand_curr % GRADIENT_TILE_SIZE);

    // Compute motion vector
    ivec2 ipos_pt_tile = (GRADIENT_TILE_SIZE * tile + offset_curr);
    ivec2 ipos_full = ipos_pt_tile * PATH_TRACE_TILE_SIZE;

    // precise vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos_full);
    // precise vec2 v = motion_data.xy * vec2(.5, -.5);
    // precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
    // iv.x = (abs(iv.x) < MOTION_VECTOR_MIN) ? 0 : iv.x;
    // iv.y = (abs(iv.y) < MOTION_VECTOR_MIN) ? 0 : iv.y;
    // ivec2 ipos_pt_tile_prev = ivec2(ipos_full + (iv + MOTION_VECTOR_OFFSET)) / PATH_TRACE_TILE_SIZE;
    // ivec2 ipos_full_prev = ipos_pt_tile_prev * PATH_TRACE_TILE_SIZE;

    ivec2 ipos_diffuse_pt_tile_prev, ipos_diffuse_full_prev;
    {
        precise vec4 motion_data = imageLoad(gbuffers[DIFFUSE_MOTION_ADDR], ipos_full);
        precise vec2 v = motion_data.xy * vec2(.5, -.5);
        precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
        ipos_diffuse_pt_tile_prev = ivec2(ipos_full + (iv + MOTION_VECTOR_OFFSET)) / PATH_TRACE_TILE_SIZE;
        ipos_diffuse_full_prev = ipos_diffuse_pt_tile_prev * PATH_TRACE_TILE_SIZE;
    }

    ivec2 ipos_specular_pt_tile_prev, ipos_specular_full_prev;
    {
        precise vec4 motion_data = imageLoad(gbuffers[SPECULAR_MOTION_ADDR_PREV], ipos_pt_tile);
        precise vec2 v = motion_data.xy * vec2(.5, -.5);
        precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height);
        ipos_specular_pt_tile_prev = ivec2(ipos_full + iv + MOTION_VECTOR_OFFSET) / PATH_TRACE_TILE_SIZE;
        ipos_specular_full_prev = ipos_specular_pt_tile_prev * PATH_TRACE_TILE_SIZE;
    }
    // {
    //     precise vec4 motion_data = imageLoad(gbuffers[SPECULAR_MOTION_ADDR], ipos_pt_tile);
    //     precise vec2 v = motion_data.xy * vec2(.5, -.5);
    //     precise vec2 iv = v.xy * vec2(push.consts.width, push.consts.height) / PATH_TRACE_TILE_SIZE;
    //     ipos_specular_pt_tile_prev = ivec2(ipos_pt_tile + iv + MOTION_VECTOR_OFFSET);
    //     ipos_specular_full_prev = ipos_specular_pt_tile_prev * PATH_TRACE_TILE_SIZE;
    // }

    vec4 diffuse_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR_PREV], ipos_diffuse_full_prev);
    vec4 specular_id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR_PREV], ipos_specular_full_prev);

    // Detect if the current pixel was rendered as a gradient sample
    // Note: A pixel is a reprojected seed if all seed values match
    bool is_diffuse_reproj_grad;
    bool is_specular_reproj_grad;
    {
        vec4 id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full);
       
        vec4 curr_diffuse_seed = imageLoad(gbuffers[DIFFUSE_SEED_ADDR], ipos_pt_tile);
        is_diffuse_reproj_grad = (curr_diffuse_seed.w > 0);// && (int(id_data.r) == int(diffuse_id_data.r));

        vec4 curr_specular_seed = imageLoad(gbuffers[SPECULAR_SEED_ADDR], ipos_pt_tile);
        is_specular_reproj_grad = (curr_specular_seed.w > 0);// && (int(id_data.r) == int(specular_id_data.r));
    }

    vec2 prev_diffuse_luminance = imageLoad(gbuffers[LUMINANCE_ADDR_PREV], ipos_diffuse_pt_tile_prev).rg;
    vec2 prev_specular_luminance = imageLoad(gbuffers[LUMINANCE_ADDR_PREV], ipos_specular_pt_tile_prev).ba;
    vec4 prev_luminance = vec4(prev_diffuse_luminance, prev_specular_luminance);
    vec4 curr_luminance = imageLoad(gbuffers[LUMINANCE_ADDR], ipos_pt_tile);
    vec4 l_prev = any(isnan(prev_luminance)) ? vec4(0.0) : prev_luminance;
    vec4 l_curr = any(isnan(curr_luminance)) ? vec4(0.0) : curr_luminance;
    vec4 temporal_gradient;
    temporal_gradient.rg = (is_diffuse_reproj_grad) ? abs(l_curr.rg - l_prev.rg) : vec2(0.0);
    temporal_gradient.ba = (is_specular_reproj_grad) ? abs(l_curr.ba - l_prev.ba) : vec2(0.0);
    // temporal_gradient.rg = (is_diffuse_reproj_grad) ? vec2(0) : vec2(0.0);
    // temporal_gradient.ba = (is_specular_reproj_grad) ? vec2(0) : vec2(0.0);
    vec4 max_luminance = max(l_curr, l_prev);

    // Compute first and second moments over the tile
    vec4 id_data = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], ipos_full);
    int mesh_id = int(id_data.r);
    vec4 first_moment = vec4(l_curr);
    vec4 second_moment = vec4(l_curr * l_curr);
    float sum_w = 1.0;
    if (PRECOMPUTE_MOMENTS) {
        for (int y = 0; y < GRADIENT_TILE_SIZE; y += 1) {
            for (int x = 0; x < GRADIENT_TILE_SIZE; x += 1) {
                ivec2 p_pt_tile = GRADIENT_TILE_SIZE * tile + ivec2(x,y);
                ivec2 p_full = p_pt_tile * PATH_TRACE_TILE_SIZE;

                // skip the center pixel, we already account for it.
                if(all(equal(ipos_pt_tile, p_pt_tile))) continue;
                
                vec4 pixel_id      = imageLoad(gbuffers[ENTITY_MATERIAL_TRANSFORM_LIGHT_ADDR], p_full);
                int mesh_id_p = int(pixel_id.r);
                
                // ignore luminance values which belong to different objects
                float w = mesh_id_p == mesh_id ? 1.0 : 0.0;
                if (w > 0.0) {
                    vec4 pixel_luminance = imageLoad(gbuffers[LUMINANCE_ADDR], p_pt_tile);
                    vec4 l = any(isnan(pixel_luminance)) ? vec4(0.0) : pixel_luminance;
                    first_moment += (l*w);
                    second_moment += (l*l*w);
                    sum_w += w;
                }
            }
        }
        first_moment /= sum_w;
        second_moment /= sum_w;
    }

    // Compute variance (second moment minus first moment squared)
    vec4 variance = abs(second_moment - first_moment * first_moment);
    if (any(isnan(variance))) variance = vec4(200);
    if (any(isinf(variance))) variance = vec4(200);

    
    imageStore(gbuffers[TEMPORAL_GRADIENT_ADDR], tile, temporal_gradient);
    imageStore(gbuffers[LUMINANCE_AVERAGE_ADDR], tile, first_moment);
    imageStore(gbuffers[LUMINANCE_VARIANCE_ADDR], tile, variance);
    imageStore(gbuffers[LUMINANCE_MAX_ADDR], tile, max_luminance);
}
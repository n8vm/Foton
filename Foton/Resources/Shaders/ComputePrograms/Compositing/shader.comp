#version 460

#define CAMERA_COMPUTE

#include "Foton/Resources/Shaders/Common/Descriptors.hxx"
#include "Foton/Resources/Shaders/Common/Options.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

// Tone Mapping
// From http://filmicgames.com/archives/75
vec3 Uncharted2Tonemap(vec3 x)
{
    x = max(x, vec3(0));
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E_ = 0.02;
	float F = 0.30;
	return max(vec3(0.0f), ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F))-E_/F);
}

void main() {
    ivec3 probeCounts = ivec3(32, 32, 32);
    int render_image_idx = int(push.consts.parameter1); 

    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 ipt_up = ivec2(gl_GlobalInvocationID.xy) / ((is_bilateral_upsampling_enabled()) ? 1 : PATH_TRACE_TILE_SIZE);
    ivec2 ipt = ivec2(gl_GlobalInvocationID.xy) / (PATH_TRACE_TILE_SIZE);
    ivec2 igt = ivec2(gl_GlobalInvocationID.xy) / (PATH_TRACE_TILE_SIZE * GRADIENT_TILE_SIZE);
    
    vec3 color;
    if (render_image_idx == 0) {
        // color = imageLoad(render_image, ipos).rgb;
        vec3 diffuse_color = imageLoad(gbuffers[DIFFUSE_COLOR_ADDR], ipos).rgb;    
        vec3 diffuse_direct = imageLoad(gbuffers[DIFFUSE_DIRECT_ADDR], ipt_up).rgb;    
        vec3 diffuse_indirect = imageLoad(gbuffers[DIFFUSE_INDIRECT_ADDR], ipt_up).rgb;    

        vec3 glossy_color = imageLoad(gbuffers[GLOSSY_COLOR_ADDR], ipos).rgb;    
        vec3 glossy_direct = imageLoad(gbuffers[GLOSSY_DIRECT_ADDR], ipt_up).rgb;    
        vec3 glossy_indirect = imageLoad(gbuffers[GLOSSY_INDIRECT_ADDR], ipt_up).rgb;    

        vec3 transmission_color = vec3(0.0);//imageLoad(gbuffers[], ipos).rgb;    
        vec3 transmission_direct = vec3(0.0);//imageLoad(gbuffers[], ipos).rgb;    
        vec3 transmission_indirect = vec3(0.0);//imageLoad(gbuffers[], ipos).rgb;    

        vec3 emission = imageLoad(gbuffers[EMISSION_ADDR], ipt_up).rgb;    
        vec3 environment = imageLoad(gbuffers[ENVIRONMENT_ADDR], ipt_up).rgb;    

        vec3 diffuse        = diffuse_color         * (diffuse_direct       + diffuse_indirect);
        vec3 glossy         = glossy_color          * (glossy_direct        + glossy_indirect);
        vec3 transmission   = transmission_color    * (transmission_direct  + transmission_indirect);

        color = diffuse + glossy + transmission + emission + environment;        
    }
    // DDGI Irradiance
    else if (
        (render_image_idx == 1)
    ) {
        const int irradianceSide = 8;
        const int irradianceWidth = (irradianceSide + 2) * probeCounts.x * probeCounts.y + 2;
        const int irradianceHeight = (irradianceSide + 2) * probeCounts.z + 2;

        ivec2 pos = ivec2((ipos / vec2(push.consts.width, push.consts.height)) * vec2(irradianceWidth, irradianceHeight));
        vec4 temp = imageLoad(DDGI_IRRADIANCE, pos);   
        color = vec3(
            temp.rgb
        );
    }
    // DDGI Visibility
    else if (
        (render_image_idx == 2)
    ) {
        const int depthSide = 16;
        const int depthWidth = (depthSide + 2) * probeCounts.x * probeCounts.y + 2;
        const int depthHeight = (depthSide + 2) * probeCounts.z + 2;

        ivec2 pos = ivec2((ipos / vec2(push.consts.width, push.consts.height)) * vec2(depthWidth, depthHeight));
        vec4 temp = imageLoad(DDGI_VISIBILITY, pos);   
        color = vec3(
            temp.r
        );
    }
    // DDGI GBuffers (5 of them)
    else if (
        (render_image_idx < 3 + 5)
    ) {
        int rays_per_probe = 64;
        int num_probes = 32 * 32 * 32;
        
        ivec2 pos = ivec2((ipos / vec2(push.consts.width, push.consts.height)) * vec2(rays_per_probe, num_probes));
        vec4 temp = imageLoad(DDGI_GBUFFERS[render_image_idx - 3], pos);   
        color = vec3(
            temp.rgb
        );
    }
    // GBuffer override for debugging
    else if ( 
        ((render_image_idx - 8) == DIFFUSE_DIRECT_ADDR) ||
        ((render_image_idx - 8) == DIFFUSE_INDIRECT_ADDR) ||
        ((render_image_idx - 8) == DIFFUSE_SEED_ADDR) ||
        // ((render_image_idx - 8) == DIFFUSE_SEED_ADDR_PREV) ||
        ((render_image_idx - 8) == SPECULAR_SEED_ADDR) ||
        ((render_image_idx - 8) == SPECULAR_SEED_ADDR_PREV) ||
        ((render_image_idx - 8) == SPECULAR_MOTION_ADDR) ||
        ((render_image_idx - 8) == SPECULAR_MOTION_ADDR_PREV) ||
        ((render_image_idx - 8) == GLOSSY_DIRECT_ADDR) ||
        ((render_image_idx - 8) == GLOSSY_INDIRECT_ADDR) ||
        ((render_image_idx - 8) == LUMINANCE_ADDR) ||
        ((render_image_idx - 8) == LUMINANCE_ADDR_PREV) ||
        ((render_image_idx - 8) == EMISSION_ADDR) ||
        ((render_image_idx - 8) == ENVIRONMENT_ADDR)
    ) {
        color = imageLoad(gbuffers[render_image_idx-1], ipt_up).rgb;   
    }
    else if (
        ((render_image_idx - 8) == SAMPLE_COUNT_ADDR)        
    ) {
        vec4 temp = imageLoad(gbuffers[render_image_idx-1], ipt);   
        color = vec3(
            temp.r / MAX_DIFFUSE_CUMULATIVE_COUNT
        );
    }
    else if (
        ((render_image_idx - 8) == NORMAL_ADDR)
    ) {
        vec4 temp = imageLoad(gbuffers[render_image_idx-1], ipt_up);   
        color = vec3(temp.w);
    }
    else if ( 
        ((render_image_idx - 8) == TEMPORAL_GRADIENT_ADDR)
    ) {
        vec4 temp = imageLoad(gbuffers[render_image_idx-1], igt);
        color = vec3(max(temp.r, temp.g), 0.0, max(temp.b, temp.a));
    }
    else if (
        ((render_image_idx - 8) == LUMINANCE_AVERAGE_ADDR) ||
        ((render_image_idx - 8) == LUMINANCE_VARIANCE_ADDR) ||
        ((render_image_idx - 8) == LUMINANCE_MAX_ADDR)
    ) {
        color = imageLoad(gbuffers[render_image_idx - 8], igt).rgb;
    }
    else {
        color = imageLoad(gbuffers[render_image_idx - 8], ipos).rgb;   
    }

    /* Tone mapping */
    color = Uncharted2Tonemap(color.rgb * push.consts.exposure);
    color = color * (1.0f / Uncharted2Tonemap(vec3(11.2f)));

    /* Gamma correction */
    color = pow(color, vec3(1.0f / push.consts.gamma));

    imageStore(render_image, ipos, vec4(color, 1.0));
}
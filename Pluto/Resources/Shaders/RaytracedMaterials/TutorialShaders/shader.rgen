#version 460
#extension GL_NV_ray_tracing : require
#define RAYTRACING

#include "Pluto/Resources/Shaders/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Pluto/Resources/Shaders/ShaderCommon.hxx"
#include "Pluto/Resources/Shaders/Options.hxx"


#define MAX_RECURSION 3
void main() 
{
    /* These are required for shading purposes. Wait until they're ready. */
    if ((push.consts.ltc_mat_lut_id < 0) || (push.consts.ltc_mat_lut_id >= MAX_TEXTURES)) return;
    if ((push.consts.ltc_amp_lut_id < 0) || (push.consts.ltc_amp_lut_id >= MAX_TEXTURES)) return;


    float r0 = samplerBlueNoiseErrorDistribution_128x128_OptimizedFor_2d2d2d2d_128spp(int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y), push.consts.frame, 0);
    float r1 = samplerBlueNoiseErrorDistribution_128x128_OptimizedFor_2d2d2d2d_128spp(int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y), push.consts.frame, 1);
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(r0, r1);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
	vec2 d = inUV * 2.0 - 1.0;
    d.y *= -1.0;
    vec4 color = vec4(0.0);

    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    
    vec3 origin = (camera_transform.localToWorld * camera.multiviews[push.consts.viewIndex].viewinv * vec4(0,0,0,1)).xyz;
	vec3 target = (camera.multiviews[push.consts.viewIndex].projinv * vec4(d.x, d.y, 1, 1)).xyz ;
    vec3 direction = (camera_transform.localToWorld * camera.multiviews[push.consts.viewIndex].viewinv * vec4(normalize(target), 0)).xyz ;

    /* Initialize ray payload */
    uint rayFlags = gl_RayFlagsNoneNV;
    uint cullMask = 0xff;
    float tmin = .01;
    float tmax = 1000.0;
    payload.bounce_count = 0;
    payload.is_shadow_ray = false;
    payload.is_specular_ray = false;
    payload.pixel = gl_LaunchIDNV.xy;
    payload.random_dimension = 0;
    traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);

    color = vec4((payload.contribution.diffuse_radiance + payload.contribution.specular_radiance), payload.contribution.alpha);

    /* Color G Buffer  */
    imageStore(render_image, ivec2(gl_LaunchIDNV.xy), color);

    if (is_taa_enabled() || is_atrous_enabled()) {
        /* Position G Buffer */
        imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(payload.WP.xyz, 0));

        vec3 oldNormalData = imageLoad(gbuffers[1], ivec2(gl_LaunchIDNV.xy)).xyz;
        vec2 oldDepthData = imageLoad(gbuffers[2], ivec2(gl_LaunchIDNV.xy)).xy;
        int oldEntityID = int(imageLoad(gbuffers[4], ivec2(gl_LaunchIDNV.xy)).x);

        /* Current Normal G Buffer */
        imageStore(gbuffers[1], ivec2(gl_LaunchIDNV.xy), vec4(payload.WN.xyz, 0));

        /* Old Normal G Buffer */
        imageStore(gbuffers[5], ivec2(gl_LaunchIDNV.xy), vec4(oldNormalData, 0));

        /* Entity ID */
        imageStore(gbuffers[4], ivec2(gl_LaunchIDNV.xy), vec4(payload.entity_id, oldEntityID, 0, 0));


        if ((payload.entity_id >= 0) && (payload.entity_id < MAX_ENTITIES))
        {

            /* Compute depth and motion vectors */
            EntityStruct entity = ebo.entities[payload.entity_id];
            TransformStruct entity_transform = tbo.transforms[entity.transform_id];
        
            
            vec4 p1 = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocal 
                * entity_transform.localToWorld * vec4(payload.P.xyz, 1.0);
            vec4 p2 = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocalPrev 
                * entity_transform.localToWorldPrev * vec4(payload.P.xyz, 1.0);

            vec3 a = (p1.xyz / p1.w);
            vec3 b = (p2.xyz / p2.w);
            
            float newDepth = a.z;
            float newReprojDepth = b.z;

            /* Depth G Buffer */
            imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(newDepth, newReprojDepth, oldDepthData));

            /* Motion Vectors G Buffer */
            imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), vec4(b - a, 1.0));

        }
        else {
            /* Depth G Buffer */
            // Note, reverse Z...
            imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(-INFINITY, -INFINITY, oldDepthData));

            /* Motion Vectors G Buffer */
            imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), vec4(0.0, 0.0, 0.0, -1.0));
        }

    }

    //     vec3 b = (p2.xyz / p2.w);
    //     float blend = 1.0;// - max(final_reflection_color.r, max(final_reflection_color.g, final_reflection_color.b));
    //     imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(b - a, blend));
    // }
    // else {
    //     imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(0.0, 0.0, 0.0, -1.0));
    // }

    // if ((payload.distance < 0.0) || (payload.entity_id < 0) || (payload.entity_id >= MAX_ENTITIES)) {
    //         color.rgb = color.rgb + (payload.contribution.diffuse + payload.contribution.specular) * (1.0 - color.a);
    //         color.a = 1.0;
    // } else {
    //     if (hit == 1) {
    //         hitID = payload.entity_id;
    //         hitPos = payload.P.xyz;
    //         final_reflection_color = payload.contribution.specular;
    //     }

    //     info.bounce_count = 0;
    //     info.entity_id = payload.entity_id;
    //     info.w_incoming = vec4(ray_direction, 0.0);
    //     info.m_position = vec4(payload.P.xyz, 1.0);
    //     info.m_normal = vec4(payload.N.xyz, 0.0);
    //     info.uv = payload.UV;
    //     // vec4 additional_color = get_ray_traced_contribution(info); // This is already done in the hit shader...
    //     color.rgb = color.rgb + (payload.contribution.diffuse + payload.contribution.specular) * (1.0 - color.a);
    //     // color.rgb += vec3(0.0, 1.0, 0.0);
    //     color.a = color.a + payload.contribution.alpha * (1.0 - color.a);

    //     if (color.a >= .9) break;

    //     ray_origin += ray_direction * payload.distance;
    // }

    
    // // /* Trace a ray to get a color */
    // PBRInfo info;
    // // info.bounce_count = 0;
    // // info.entity_id = entity_id;
    // // info.w_incoming = vec4(w_incoming, 0.0);
    // // info.m_position = vec4(m_position, 0.0);
    // // info.m_normal = vec4(m_normal, 0.0);
    // // info.uv = uv;

    // //get_ray_traced_contribution(info);

    // vec3 ray_origin = origin.xyz;
    // vec3 ray_direction = direction.xyz;

    // vec3 hitPos;
    // int hitID = -1;
    // vec3 final_reflection_color = vec3(0.0);

    // int max_hits = 20;
    // int hit = 0;
    // while (color.a < 1.0) {
    //     if (hit >= max_hits) break;
    //     hit++;
    //     // uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV ;
        
    //     // vec3 dir = w_refl.xyz;


        
    // }


}

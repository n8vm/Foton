#version 460
#extension GL_NV_ray_tracing : require
#define RAYTRACING

#include "Pluto/Resources/Shaders/Descriptors.hxx"
#include "Pluto/Resources/Shaders/ShaderCommon.hxx"

layout(location = 0) rayPayloadNV HitInfo payload;

#define MAX_RECURSION 1
void main() 
{
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);

    vec3 w_normal = imageLoad(normal_image, ivec2(gl_LaunchIDNV.xy)).xyz;
    vec3 w_position = imageLoad(position_image, ivec2(gl_LaunchIDNV.xy)).xyz;
    vec4 raster_contribution = imageLoad(render_image, ivec2(gl_LaunchIDNV.xy));

    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];

    /* Note, multiview not supported in rgen shaders */
    vec3 w_cameraPos = vec3(camera_transform.localToWorld[3]);
    vec3 w_cameraDir = normalize(w_cameraPos - w_position);

    vec3 w_view = normalize(w_cameraDir);
	vec3 w_refl = -normalize(reflect(w_view, w_normal));	

    /* No object in view. TODO: change to entity*/
    if (length(w_position) < .0001) return;

    /* Initialize payload */
    // payload.N = vec4(0.);
    // payload.P = vec4(0.);
    // payload.C = vec4(0.);
    // payload.UV = vec2(0.);
    // payload.entity_id = -1;
    // payload.distance = -1;

    vec4 finalColor = raster_contribution;
    for (int i = 0; i < MAX_RECURSION; i++) {
        /* Trace reflections */
        uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV ;
        uint cullMask = 0xff;
        float tmin = .01;
        float tmax = 100.0;
        vec3 dir = w_refl.xyz;
        traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, w_position.xyz - w_normal * .01, tmin, dir, tmax, 0);
        
        if ((payload.distance < 0.0)
            || (payload.entity_id < 0) || (payload.entity_id >= MAX_ENTITIES)
        ) break;
        EntityStruct entity = ebo.entities[payload.entity_id];

        if (entity.material_id < 0 || entity.material_id >= MAX_MATERIALS) break;
        MaterialStruct material = mbo.materials[entity.material_id];

        if (entity.transform_id < 0 || entity.transform_id >= MAX_TRANSFORMS) break;
        TransformStruct transform = tbo.transforms[entity.transform_id];

        /* TODO: Handle alpha compositing */
        vec3 MP = (payload.P).xyz;
        vec3 WP = (transform.localToWorld * vec4(payload.P.xyz, 1.0)).xyz;
        vec3 WN = normalize((transpose(transform.worldToLocal) * vec4(payload.N.xyz, 0.0)).xyz);
        vec3 V = -dir;
        finalColor += vec4(get_color_contribution(material, WN, V, WP, MP, payload.UV, payload.C).rgb, 0.0) * .5;
        // finalColor = vec4(WN, 1.0);
        /* Temporary */
        break;
    }

    imageStore(render_image, ivec2(gl_LaunchIDNV.xy), finalColor);




    // const uint cullMask = 0xFF;
    // const uint sbtRecordOffset = 0;
    // const uint sbtRecordStride = 0;
    // const uint missIndex = 0;
    // const float tmin = 0.0f;
    // const float tmax = 10000.0f;
    // const int payloadLocation = 0;

    // traceNV(topLevelAS,
    //          rayFlags,
    //          cullMask,
    //          sbtRecordOffset,
    //          sbtRecordStride,
    //          missIndex,
    //          origin,
    //          tmin,
    //          direction,
    //          tmax,
    //          payloadLocation);

    // uint rayFlags = gl_RayFlagsOpaqueNV;
    // uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV ;

	// MaterialStruct material = mbo.materials[entity.material_id];
    
    

}
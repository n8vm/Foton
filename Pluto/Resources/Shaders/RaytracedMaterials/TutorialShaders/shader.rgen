#version 460
#extension GL_NV_ray_tracing : require
#define RAYTRACING

#include "Pluto/Resources/Shaders/Descriptors.hxx"
layout(location = 0) rayPayloadNV HitInfo payload;
#include "Pluto/Resources/Shaders/ShaderCommon.hxx"
#include "Pluto/Resources/Shaders/Options.hxx"

vec3 sample_direct_light(const in ivec2 pixel_coords, const in MaterialStruct mat, bool backface, const in vec3 w_p, const in vec3 w_n,
	const in vec3 w_x, const in vec3 w_y, const in vec3 w_o, out int light_entity_id)
{
	vec3 radiance = vec3(0.0f);

    vec3 w_n_f = (backface) ? -w_n : w_n;

    /* Pick a random light */
    EntityStruct light_entity; TransformStruct light_transform;
    LightStruct light; MaterialStruct light_material;
    bool light_found = false;
    int tries = 0;
    while ((!light_found) && (tries < 3) && (push.consts.num_lights > 0)) {
        tries++;
        int i = int((random(pixel_coords) - EPSILON) * (push.consts.num_lights));
        light_entity_id = lidbo.lightIDs[i];
        if (light_entity_id == -1) continue;
        unpack_entity(light_entity_id, light_entity, light_transform, light_material, light);
        if ( (light_entity.initialized != 1) || (light_entity.transform_id == -1)) continue;
        light_found = true;
    }

    /* If we didn't find a light, return. (Shouldn't happen except during initialization) */
    if (!light_found) return radiance;

    // Importance sample the light directly
    /* Compute the outgoing radiance for this light */
    bool light_is_double_sided = bool(light.flags & (1 << 0));
    mat3 m_inv;

    /* Compute direct specular and diffuse contribution from LTC area lights */
    // vec2 LTC_UV = vec2(max(mat.roughness, EPSILON), sqrt(1.0 - dot(SI.w_n.xyz, -SI.w_i.xyz)))*LUT_SCALE + LUT_BIAS;
    // vec4 t1 = texture(sampler2D(texture_2Ds[push.consts.ltc_mat_lut_id], samplers[0]), LTC_UV);
    // vec4 t2 = texture(sampler2D(texture_2Ds[push.consts.ltc_amp_lut_id], samplers[0]), LTC_UV);
    // m_inv = mat3(
    //     vec3(t1.x, 0, t1.y),
    //     vec3(  0,  1,    0),
    //     vec3(t1.z, 0, t1.w)
    // );

    vec3 w_i;

    /* Compute differential irradiance and visibility */
    {
        float light_pdf = 0.;
        float visibility = 1.;
        vec3 Li = vec3(0);   
        if (light.type == LIGHT_TYPE_POINT) {
            Li = sphereLightSample(pixel_coords, light_entity, light, light_transform, w_p, w_n_f, w_i, light_pdf);
        }
        else if( light.type == LIGHT_TYPE_RECTANGLE ) {
            Li = rectangleLightSample(pixel_coords, light_entity, light, light_transform, w_p, w_n_f, w_i, light_pdf);
        }
        else if (light.type == LIGHT_TYPE_DISK) {
            Li = sphereLightSample(pixel_coords, light_entity, light, light_transform, w_p, w_n_f, w_i, light_pdf);
        }
        else if (light.type == LIGHT_TYPE_ROD) {
            Li = sphereLightSample(pixel_coords, light_entity, light, light_transform, w_p, w_n_f, w_i, light_pdf);
        }
        else if( light.type == LIGHT_TYPE_SPHERE ) {
            Li = sphereLightSample(pixel_coords, light_entity, light, light_transform, w_p, w_n_f, w_i, light_pdf);
        }

        float bsdf_pdf = disney_pdf(mat, backface, w_n, w_o, w_i, w_x, w_y);

        /* Compute visibility by tracing a shadow ray */
        {
            /* Trace a single shadow ray */
            uint rayFlags = gl_RayFlagsNoneNV;
            uint cullMask = 0xff;
            float tmax = INFINITY;
            payload.is_shadow_ray = true; 
            traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, w_p, TMIN, w_i, tmax, 0); 
            visibility = (payload.entity_id == light_entity_id) ? 1.0 : 0.0;
        }

        if (light_pdf >= EPSILON && bsdf_pdf >= EPSILON && visibility == 1.0) {
            vec3 bsdf = disney_brdf(mat, backface, w_n, w_o, w_i, w_x, w_y);
            float w = power_heuristic(1.f, light_pdf, 1.f, bsdf_pdf);
            radiance = bsdf * Li * abs(dot(w_i, w_n_f)) * w / light_pdf;
        }
    }

    // Sample the BRDF to compute a light sample as well
	{
		vec3 w_i;
		float bsdf_pdf;
        float visibility = 1.0;
		vec3 bsdf = sample_disney_brdf(pixel_coords, mat, backface, w_n, w_o, w_x, w_y, w_i, bsdf_pdf);
		
		float light_dist;
		vec3 light_pos;
		if (any(greaterThan(bsdf, vec3(0.f))) && bsdf_pdf >= EPSILON
			/*&& quad_intersect(light, w_p, w_i, light_dist, light_pos)*/
        ) {
			float light_pdf; // = quad_light_pdf(light, light_pos, w_p, w_i);
            vec3 Li;
            if (light.type == LIGHT_TYPE_POINT) {
                light_pdf = sphereLightPDF(light_entity, light, light_transform, w_p, w_n_f);
            }
            else if( light.type == LIGHT_TYPE_RECTANGLE ) {
                light_pdf = rectangleLightPDF(light_entity, light, light_transform, w_p, w_n_f);
            }
            else if (light.type == LIGHT_TYPE_DISK) {
                light_pdf = sphereLightPDF(light_entity, light, light_transform, w_p, w_n_f);
            }
            else if (light.type == LIGHT_TYPE_ROD) {
                light_pdf = sphereLightPDF(light_entity, light, light_transform, w_p, w_n_f);
            }
            else if( light.type == LIGHT_TYPE_SPHERE ) {
                light_pdf = sphereLightPDF(light_entity, light, light_transform, w_p, w_n_f);
            }
            Li = light.color.rgb * light.intensity;
			if (light_pdf >= EPSILON) {
				float w = power_heuristic(1.f, bsdf_pdf, 1.f, light_pdf);

                /* Compute visibility by tracing a shadow ray */
                {
                    /* Trace a single shadow ray */
                    payload.is_shadow_ray = true; 
                    traceNV(topLevelAS, /*gl_RayFlagsTerminateOnFirstHitNV*/gl_RayFlagsNoneNV, 0xff, 0, 0, 0, w_p, TMIN, w_i, TMAX, 0); // UPDATE TMAX TO BE LIGHT DIST
                    visibility = (payload.entity_id == light_entity_id) ? 1.0 : 0.0;
                }
                
				if (visibility == 1.0) {
					radiance += visibility * bsdf * Li * abs(dot(w_i, w_n_f)) * w / bsdf_pdf;
				}
			}
		}
	}





    // bool isBlack = false;
    // isBlack = dot(Li, Li) <= EPSILON;
    // float light_scattering_pdf = 1.;
    // float light_weight = 1.0;
    // if (lightPdf > EPSILON && !isBlack ) {
    //     vec3 f = bsdfEvaluate(w_i, w_o, SI, hit_entity_material) * abs(dot(w_i, w_n));
        
    //     light_scattering_pdf = bsdfPdf(wi, wo, SI, hit_entity_material);
    //     light_weight = powerHeuristic(1., lightPdf, 1., light_scattering_pdf);

    //     isBlack = dot(f, f) <= EPSILON;
    //     if (!isBlack) {
    //         Ld += Li * f * (light_weight / max(lightPdf, EPSILON));
    //     }
    // }

    // /* Compute outgoing radiance from the light by sampling the BRDF */
    // float brdf_scattering_pdf = 1.0;
    // float brdf_weight = 1.0;

    // // if (!SI.is_specular) 
    // {
    //     /* Compute a random reflection direction */
    //     bool is_specular;
    //     vec3 f = bsdfSample(random(SI.pixel_coords), random(SI.pixel_coords), random(SI.pixel_coords), 
    //         wi, wo, brdf_scattering_pdf, is_specular, SI, hit_entity_material);
    //     f *= abs(dot(wi, SI.w_n.xyz));
    //     isBlack = dot(f, f) <= EPSILON;
    //     brdf_weight = powerHeuristic(1., brdf_scattering_pdf, 1., lightPdf);

    //     if (!isBlack && (brdf_scattering_pdf > EPSILON) && (brdf_weight > EPSILON)) {
    //         /* Compute differential irradiance */
    //         float tmax = 100;
    //         uint rayFlags = gl_RayFlagsNoneNV;
    //         uint cullMask = 0xff;
    //         payload.is_shadow_ray = false; 
    //         traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, SI.w_p.xyz, TMIN, wi, tmax, 0);
    //         if ((payload.entity_id == light_entity_id) /*&& (light_is_double_sided || (!payload.backface))*/)
    //             Li = light.color.rgb * light.intensity;
    //         else 
    //             Li = vec3(0.0);

    //         // if (payload.entity_id == -1) brdf_weight = 1.0;
    //         isBlack = dot(Li, Li) <= EPSILON;
    //         if (!isBlack) {
    //             Ld += Li * f * (brdf_weight / max(brdf_scattering_pdf, EPSILON));
    //         }
    //     }
    // }



    // illum = vec3(1.0);

	return radiance;
}

void main() 
{
    /* These are required for shading purposes. Wait until they're ready. */
    if ((push.consts.ltc_mat_lut_id < 0) || (push.consts.ltc_mat_lut_id >= MAX_TEXTURES)) return;
    if ((push.consts.ltc_amp_lut_id < 0) || (push.consts.ltc_amp_lut_id >= MAX_TEXTURES)) return;
    
    /* First, update G Buffer history */
    vec4 temp;

    // Position G Buffer 
    temp = imageLoad(gbuffers[0], ivec2(gl_LaunchIDNV.xy));
    imageStore(gbuffers[1], ivec2(gl_LaunchIDNV.xy), temp);

    // Normal G Buffer
    temp = imageLoad(gbuffers[2], ivec2(gl_LaunchIDNV.xy));
    imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), temp);

    // Raw albedo
    temp = imageLoad(gbuffers[4], ivec2(gl_LaunchIDNV.xy));
    imageStore(gbuffers[5], ivec2(gl_LaunchIDNV.xy), temp);

    /* Now, Compute ray origin and direction */
    randomDimension = 0;
    int max_path_depth = int(push.consts.parameter1);

    const ivec2 pixel_coords = ivec2(gl_LaunchIDNV.xy);
    const vec2 pixel_center = vec2(gl_LaunchIDNV.xy) + vec2(random(pixel_coords), random(pixel_coords));
	const vec2 in_uv = pixel_center/vec2(gl_LaunchSizeNV.xy);
	vec2 d = in_uv * 2.0 - 1.0; d.y *= -1.0;

    EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
    CameraStruct camera = cbo.cameras[camera_entity.camera_id];
    TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    
    vec3 origin = (camera_transform.localToWorld * camera.multiviews[push.consts.viewIndex].viewinv * vec4(0,0,0,1)).xyz;
	vec3 target = (camera.multiviews[push.consts.viewIndex].projinv * vec4(d.x, d.y, 1, 1)).xyz ;
    vec3 direction = (camera_transform.localToWorld * camera.multiviews[push.consts.viewIndex].viewinv * vec4(normalize(target), 0)).xyz ;
    direction = normalize(direction);
    
    vec4 color = vec4(0.0);
    int bounce = 0;
    bool last_event_was_specular = true;
    vec3 path_throughput = vec3(1.0);
    int last_direct_light_entity_id = -2;


    vec3 first_hit_world_position = vec3(INFINITY);
    vec3 first_hit_model_position = vec3(INFINITY);
    vec3 first_hit_normal = vec3(INFINITY);
    vec3 first_hit_albedo = vec3(0.0);
    vec3 first_hit_direct = vec3(0.0);
    float first_hit_distance = INFINITY;

    int first_hit_entity_id = -1;
    EntityStruct first_hit_entity;
    first_hit_entity.initialized = 0;

    do{
        /* Trace a ray through the scene */
        payload.is_shadow_ray = false;
        traceNV(topLevelAS, gl_RayFlagsNoneNV, 0xff, 0, 0, 0, origin, TMIN, direction, TMAX, 0);

        /* If we hit the sky... */
        if (payload.entity_id == -1) {
            vec3 irradiance = get_environment_color(direction);
            /* Include lighting from sky as direct lighting.  */
            if ((bounce == 0) || (bounce == 1)) first_hit_direct += path_throughput * irradiance;
            /* Primary visibility is sky */
            if (bounce == 0) first_hit_albedo = irradiance;
            color.rgb += path_throughput * irradiance;
            break;
        }

        /* Don't double count light sources */
        if (payload.entity_id == last_direct_light_entity_id) {
            break;
        }

        int entity_id = payload.entity_id;
        EntityStruct entity; MaterialStruct mat; LightStruct light;
        unpack_entity_struct(payload.entity_id, entity);
        unpack_material_struct(payload.entity_id, entity, payload.uv, payload.m_p, mat);
        unpack_light_struct(payload.entity_id, entity, light);

        vec3 w_o = -direction;
        vec3 w_p = payload.w_p;
        vec3 m_p = payload.m_p;
        vec3 w_x, w_y, w_z;
        w_z = payload.w_n;
        bool backface = payload.backface;
        float dist = payload.distance;

        directionOfAnisotropicity(w_z, w_x, w_y);

        /* If we're a light, radiate */
        if ((entity.light_id >= 0) && (entity.light_id < MAX_LIGHTS)) {
            color.rgb += path_throughput * light.color.rgb * light.intensity;
            if (bounce == 0) {
                first_hit_entity_id = entity_id;
                first_hit_entity = entity;
                first_hit_world_position = w_p;
                first_hit_model_position = m_p;
                first_hit_distance = dist;
                first_hit_normal = w_z;
                first_hit_albedo = light.color.rgb;
                first_hit_direct = color.rgb;
            }
            break;
        }

        /* If the object is completely transparent, go through it  */
        if (mat.base_color.a < EPSILON) {
            origin = payload.w_p + EPSILON * direction;
            continue;
        }

        /* Next event estimation */
        color.rgb += path_throughput * sample_direct_light(pixel_coords, mat, backface, w_p, w_z, w_x, w_y, w_o, last_direct_light_entity_id); 

        /* Record first hit data */
        if (bounce == 0) {
            first_hit_entity_id = entity_id;
            first_hit_entity = entity;
            first_hit_world_position = w_p;
            first_hit_model_position = m_p;
            first_hit_distance = dist;
            first_hit_normal = w_z;
            first_hit_albedo = mat.base_color.rgb;
            first_hit_direct = color.rgb;
        }

        bounce++;

        /* Avoid sampling the brdf if this is the last path position */
        if (bounce > max_path_depth) break;

        /* Setup next ray */
        vec3 w_i; float pdf;
        vec3 bsdf = sample_disney_brdf(pixel_coords, mat, backface, w_z, w_o, w_x, w_y, w_i, pdf);
        if (pdf < EPSILON || all(lessThan(bsdf, vec3(EPSILON)))) {
            break;
        }

        path_throughput *= bsdf / pdf;

        if (all(lessThan(path_throughput, vec3(EPSILON)))) {
            break;
        }

        origin = w_p;
        direction = w_i;
    } while (bounce <= max_path_depth);

    // if (any(isnan(color))) color = vec4(1.0, 0.0, 1.0, 1.0);
    // if (any(isinf(color))) color = vec4(0.0, 1.0, 1.0, 1.0);

    /* Compute motion vector for primary visibility */
    vec3 motion = vec3(0.0);
    bool reset = true;
    if (first_hit_entity.initialized == 1) {
        reset = false;
        TransformStruct transform = tbo.transforms[first_hit_entity.transform_id];
        vec4 w_p_prev = transform.localToWorldPrev * vec4(first_hit_model_position, 1.0);

        vec4 v_p_curr = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocal * vec4(first_hit_world_position, 1.0);
        vec4 v_p_prev = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocalPrev * w_p_prev;

        motion = (v_p_prev.xyz / v_p_prev.w) - (v_p_curr.xyz / v_p_curr.w);
    }

    /* Write to G Buffers */

    // Position G Buffer
    imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(first_hit_world_position, first_hit_distance));

    // Normal G Buffer
    imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(first_hit_normal, 0));

    // Raw albedo
    imageStore(gbuffers[4], ivec2(gl_LaunchIDNV.xy), vec4(first_hit_albedo, first_hit_entity_id));

    // Motion Vector G Buffer
    imageStore(gbuffers[6], ivec2(gl_LaunchIDNV.xy), vec4(motion, (reset) ? 1.0 : 0.0));

    // Demodulated direct illumination 
    vec3 demodulated_direct = first_hit_direct / (first_hit_albedo + vec3(EPSILON)); 
    imageStore(gbuffers[7], ivec2(gl_LaunchIDNV.xy), vec4(demodulated_direct, 0));

    // Demodulated indirect illumination
    vec3 demodulated_indirect = (color.rgb - first_hit_direct) / (first_hit_albedo + vec3(EPSILON));
    imageStore(gbuffers[8], ivec2(gl_LaunchIDNV.xy), vec4(demodulated_indirect, 0));


    // if (is_taa_enabled() || is_atrous_enabled()) {
        

        // vec3 oldNormalData = imageLoad(gbuffers[1], ivec2(gl_LaunchIDNV.xy)).xyz;
        // vec2 oldDepthData = imageLoad(gbuffers[2], ivec2(gl_LaunchIDNV.xy)).xy;
        // int oldEntityID = int(imageLoad(gbuffers[4], ivec2(gl_LaunchIDNV.xy)).x);

        

        /* Current Raw Albedo */
        

        // /* Old Normal G Buffer */
        // imageStore(gbuffers[5], ivec2(gl_LaunchIDNV.xy), vec4(oldNormalData, 0));

        /* Entity ID */
        // imageStore(gbuffers[4], ivec2(gl_LaunchIDNV.xy), vec4(payload.entity_id, oldEntityID, 0, 0));


        // if ((payload.entity_id >= 0) && (payload.entity_id < MAX_ENTITIES))
        // {
        //     /* Compute depth and motion vectors */
        //     EntityStruct entity = ebo.entities[payload.entity_id];
        //     TransformStruct entity_transform = tbo.transforms[entity.transform_id];
        
            
        //     vec4 p1 = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocal 
        //         * entity_transform.localToWorld * vec4(payload.P.xyz, 1.0);
        //     vec4 p2 = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocalPrev 
        //         * entity_transform.localToWorldPrev * vec4(payload.P.xyz, 1.0);

        //     vec3 a = (p1.xyz / p1.w);
        //     vec3 b = (p2.xyz / p2.w);
            
        //     float newDepth = a.z;
        //     float newReprojDepth = b.z;

        //     /* Depth G Buffer */
        //     imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(newDepth, newReprojDepth, oldDepthData));

        //     /* Motion Vectors G Buffer */
        //     imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), vec4(b - a, 1.0));

        // }
        // else 
        // {
        //     /* Depth G Buffer */
        //     // Note, reverse Z...
        //     imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(-INFINITY, -INFINITY, oldDepthData));

        //     /* Motion Vectors G Buffer */
        //     imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), vec4(0.0, 0.0, 0.0, -1.0));
        // }

    // }
}
    // do {
    //     /* Trace a ray through the scene */
    //     payload.is_shadow_ray = false;
    //     traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, TMIN, direction, TMAX, 0);
        
    //     /* We hit the sky.  */
    //     if (payload.entity_id == -1) {
    //         vec3 irradiance = get_environment_color(direction);
    //         // vec3 radiance = irradiance; // todo: multiply BRDF, divide by pdf
    //         if (!any(isnan(path_throughput * irradiance))) 
    //             color.rgb += path_throughput * irradiance;
    //         // color.rgb = color.rgb * color.a + (1.0 - color.a) * radiance; 
    //         // color.a = 1.0;
    //         break;
    //     }

    //     // /* We hit the last direct light */
    //     // if (payload.entity_id == last_direct_light_entity_id) {
    //     //     break;
    //     // }

    //     /* We hit an object. Load any additional required data. */ 
    //     EntityStruct hit_entity = ebo.entities[payload.entity_id];
    //     TransformStruct hit_entity_transform = tbo.transforms[hit_entity.transform_id];
    //     MaterialStruct hit_entity_material = mbo.materials[hit_entity.material_id];
    //     LightStruct hit_entity_light;
    //     bool hit_entity_is_emissive = ((hit_entity.light_id < MAX_LIGHTS) && (hit_entity.light_id >= 0));
    //     if (hit_entity_is_emissive) hit_entity_light = lbo.lights[hit_entity.light_id];
    //     mat3 normal_matrix = transpose(mat3(hit_entity_transform.worldToLocal));
        
    //     /* Setup surface interaction */
    //     SurfaceInteraction SI;
    //     SI.entity_id = payload.entity_id;
    //     SI.m_p = payload.P;
    //     SI.m_n = payload.N;
    //     // SI.m_t = payload.X;
    //     // SI.m_b = payload.Y;
    //     SI.w_i = direction;
    //     SI.w_p = hit_entity_transform.localToWorld * SI.m_p;
    //     SI.w_n = normalize(normal_matrix * SI.m_n);
    //     directionOfAnisotropicity(SI.w_n, SI.w_t, SI.w_b);
    //     SI.uv = payload.UV;
    //     SI.is_specular = false;
    //     SI.pixel_coords = pixel_coords;
    //     vec3 Ld = vec3(0.);
    //     vec3 wi;
    //     vec3 wo = -SI.w_i.xyz;

    //     // for now, flip normals to face the camera
    //     if (dot(SI.w_n, direction) > 0) {
    //         SI.w_n *= -1.0; SI.w_t *= -1.0; SI.w_b *= -1.0;
    //         SI.m_n *= -1.0; SI.m_t *= -1.0; SI.m_b *= -1.0;
    //     }

    //     /* Compute radiance from the hit object back to source. */

    //     /* If the hit object was emissive and the last event was specular, radiate */
    //     if (hit_entity_is_emissive && last_event_was_specular) {
    //         Ld += hit_entity_light.color.rgb * hit_entity_light.intensity;
    //     }

    //     /* Pick a random light for next event estimation */
    //     int light_entity_id;
    //     EntityStruct light_entity;
    //     TransformStruct light_transform;
    //     LightStruct light;
    //     bool light_found = false;
    //     int tries = 0;
    //     while ((!light_found) && (tries < 3) && (push.consts.num_lights > 0)) {
    //         tries++;
    //         int i = int((random(SI.pixel_coords) - EPSILON) * (push.consts.num_lights));
    //         /* Skip unused lights and lights without a transform */
    //         light_entity_id = lidbo.lightIDs[i];
    //         if (light_entity_id == -1) continue;
    //         // if (light_entity_id == interaction.entity_id) break;
    //         light_entity = ebo.entities[light_entity_id];
    //         if ( (light_entity.initialized != 1) || (light_entity.transform_id == -1)) continue;
    //         light_found = true;
    //         light = lbo.lights[light_entity.light_id];
    //         light_transform = tbo.transforms[light_entity.transform_id];
    //     }

    //     /* If we didn't find a light, return */
    //     if (!light_found) break;

    

    //     /* Add incoming radiance (weighted by prior brdfs*weights/pdfs) to the ray */
    //     color.rgb += path_throughput * Ld;
        

    //     /* Setup origin and direction for next ray */
    //     bool is_specular;
    //     brdf_weight = 1.0;
    //     brdf_scattering_pdf = 1.0;
    //     vec3 f = bsdfSample(random(SI.pixel_coords), random(SI.pixel_coords), random(SI.pixel_coords), 
    //         wi, wo, brdf_scattering_pdf, is_specular, SI, hit_entity_material);
    //     f *= abs(dot(wi, SI.w_n.xyz));
    //     isBlack = dot(f, f) <= EPSILON;
    //     if (isBlack) break;
    //     path_throughput *= f * (brdf_weight / max(brdf_scattering_pdf, EPSILON));
    //     origin = SI.w_p.xyz;
    //     direction = wi;
    //     last_direct_light_entity_id = light_entity_id;
    //     last_event_was_specular = false;

    //     ++bounce;
    // } while (bounce < max_path_depth);


// void main() 
// {
//     /* These are required for shading purposes. Wait until they're ready. */
//     if ((push.consts.ltc_mat_lut_id < 0) || (push.consts.ltc_mat_lut_id >= MAX_TEXTURES)) return;
//     if ((push.consts.ltc_amp_lut_id < 0) || (push.consts.ltc_amp_lut_id >= MAX_TEXTURES)) return;


//     float r0 = samplerBlueNoiseErrorDistribution_128x128_OptimizedFor_2d2d2d2d_128spp(int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y), push.consts.frame, 0);
//     float r1 = samplerBlueNoiseErrorDistribution_128x128_OptimizedFor_2d2d2d2d_128spp(int(gl_LaunchIDNV.x), int(gl_LaunchIDNV.y), push.consts.frame, 1);
//     const vec2 pixel_center = vec2(gl_LaunchIDNV.xy) + vec2(r0, r1);
// 	const vec2 inUV = pixel_center/vec2(gl_LaunchSizeNV.xy);
// 	vec2 d = inUV * 2.0 - 1.0;
//     d.y *= -1.0;
//     vec4 color = vec4(0.0);

//     EntityStruct camera_entity = ebo.entities[push.consts.camera_id];
//     CameraStruct camera = cbo.cameras[camera_entity.camera_id];
//     TransformStruct camera_transform = tbo.transforms[camera_entity.transform_id];
    
//     vec3 origin = (camera_transform.localToWorld * camera.multiviews[push.consts.viewIndex].viewinv * vec4(0,0,0,1)).xyz;
// 	vec3 target = (camera.multiviews[push.consts.viewIndex].projinv * vec4(d.x, d.y, 1, 1)).xyz ;
//     vec3 direction = (camera_transform.localToWorld * camera.multiviews[push.consts.viewIndex].viewinv * vec4(normalize(target), 0)).xyz ;

//     /* Initialize ray payload */
//     uint rayFlags = gl_RayFlagsNoneNV;
//     uint cullMask = 0xff;
//     float tmin = .01;
//     float tmax = 1000.0;
//     payload.bounce = 0;
//     payload.is_shadow_ray = false;
//     payload.is_specular_ray = false;
//     payload.pixel = gl_LaunchIDNV.xy;
//     payload.random_dimension = 0;
//     traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);

//     color = vec4((payload.contribution.diffuse_radiance + payload.contribution.specular_radiance), payload.contribution.alpha);

//     /* Color G Buffer  */
//     imageStore(render_image, ivec2(gl_LaunchIDNV.xy), color);

//     if (is_taa_enabled() || is_atrous_enabled()) {
//         /* Position G Buffer */
//         imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(payload.WP.xyz, 0));

//         vec3 oldNormalData = imageLoad(gbuffers[1], ivec2(gl_LaunchIDNV.xy)).xyz;
//         vec2 oldDepthData = imageLoad(gbuffers[2], ivec2(gl_LaunchIDNV.xy)).xy;
//         int oldEntityID = int(imageLoad(gbuffers[4], ivec2(gl_LaunchIDNV.xy)).x);

//         /* Current Normal G Buffer */
//         imageStore(gbuffers[1], ivec2(gl_LaunchIDNV.xy), vec4(payload.WN.xyz, 0));

//         /* Old Normal G Buffer */
//         imageStore(gbuffers[5], ivec2(gl_LaunchIDNV.xy), vec4(oldNormalData, 0));

//         /* Entity ID */
//         imageStore(gbuffers[4], ivec2(gl_LaunchIDNV.xy), vec4(payload.entity_id, oldEntityID, 0, 0));


//         if ((payload.entity_id >= 0) && (payload.entity_id < MAX_ENTITIES))
//         {

//             /* Compute depth and motion vectors */
//             EntityStruct entity = ebo.entities[payload.entity_id];
//             TransformStruct entity_transform = tbo.transforms[entity.transform_id];
        
            
//             vec4 p1 = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocal 
//                 * entity_transform.localToWorld * vec4(payload.P.xyz, 1.0);
//             vec4 p2 = camera.multiviews[push.consts.viewIndex].viewproj * camera_transform.worldToLocalPrev 
//                 * entity_transform.localToWorldPrev * vec4(payload.P.xyz, 1.0);

//             vec3 a = (p1.xyz / p1.w);
//             vec3 b = (p2.xyz / p2.w);
            
//             float newDepth = a.z;
//             float newReprojDepth = b.z;

//             /* Depth G Buffer */
//             imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(newDepth, newReprojDepth, oldDepthData));

//             /* Motion Vectors G Buffer */
//             imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), vec4(b - a, 1.0));

//         }
//         else {
//             /* Depth G Buffer */
//             // Note, reverse Z...
//             imageStore(gbuffers[2], ivec2(gl_LaunchIDNV.xy), vec4(-INFINITY, -INFINITY, oldDepthData));

//             /* Motion Vectors G Buffer */
//             imageStore(gbuffers[3], ivec2(gl_LaunchIDNV.xy), vec4(0.0, 0.0, 0.0, -1.0));
//         }

//     }

//     //     vec3 b = (p2.xyz / p2.w);
//     //     float blend = 1.0;// - max(final_reflection_color.r, max(final_reflection_color.g, final_reflection_color.b));
//     //     imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(b - a, blend));
//     // }
//     // else {
//     //     imageStore(gbuffers[0], ivec2(gl_LaunchIDNV.xy), vec4(0.0, 0.0, 0.0, -1.0));
//     // }

//     // if ((payload.distance < 0.0) || (payload.entity_id < 0) || (payload.entity_id >= MAX_ENTITIES)) {
//     //         color.rgb = color.rgb + (payload.contribution.diffuse + payload.contribution.specular) * (1.0 - color.a);
//     //         color.a = 1.0;
//     // } else {
//     //     if (hit == 1) {
//     //         hitID = payload.entity_id;
//     //         hitPos = payload.P.xyz;
//     //         final_reflection_color = payload.contribution.specular;
//     //     }

//     //     info.bounce = 0;
//     //     info.entity_id = payload.entity_id;
//     //     info.w_incoming = vec4(ray_direction, 0.0);
//     //     info.m_position = vec4(payload.P.xyz, 1.0);
//     //     info.m_normal = vec4(payload.N.xyz, 0.0);
//     //     info.uv = payload.UV;
//     //     // vec4 additional_color = get_ray_traced_contribution(info); // This is already done in the hit shader...
//     //     color.rgb = color.rgb + (payload.contribution.diffuse + payload.contribution.specular) * (1.0 - color.a);
//     //     // color.rgb += vec3(0.0, 1.0, 0.0);
//     //     color.a = color.a + payload.contribution.alpha * (1.0 - color.a);

//     //     if (color.a >= .9) break;

//     //     ray_origin += ray_direction * payload.distance;
//     // }

    
//     // // /* Trace a ray to get a color */
//     // PBRInfo info;
//     // // info.bounce = 0;
//     // // info.entity_id = entity_id;
//     // // info.w_incoming = vec4(w_incoming, 0.0);
//     // // info.m_position = vec4(m_position, 0.0);
//     // // info.m_normal = vec4(m_normal, 0.0);
//     // // info.uv = uv;

//     // //get_ray_traced_contribution(info);

//     // vec3 ray_origin = origin.xyz;
//     // vec3 ray_direction = direction.xyz;

//     // vec3 hitPos;
//     // int hitID = -1;
//     // vec3 final_reflection_color = vec3(0.0);

//     // int max_hits = 20;
//     // int hit = 0;
//     // while (color.a < 1.0) {
//     //     if (hit >= max_hits) break;
//     //     hit++;
//     //     // uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV ;
        
//     //     // vec3 dir = w_refl.xyz;


        
//     // }


// }
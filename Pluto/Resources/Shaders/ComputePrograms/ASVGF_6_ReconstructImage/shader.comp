#version 460
#pragma optionNV (unroll all)

/* Denoises raw color data before being fed into the geometric TAA */

#define COMPUTE

#include "Pluto/Resources/Shaders/Common/Descriptors.hxx"
#include "Pluto/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Pluto/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

#define RADIUS 2
const float h[5][5] = {
    {1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0},
    {1.0/64.0,  1.0/16.0, 3.0/32.0,  1.0/16.0, 1.0/64.0},
    {3.0/128.0, 3.0/32.0, 9.0/64.0,  3.0/32.0, 3.0/128.0},
    {1.0/64.0,  1.0/16.0, 3.0/32.0,  1.0/16.0, 1.0/64.0},
    {1.0/256.0, 1.0/64.0, 3.0/128.0, 1.0/64.0, 1.0/256.0}
};

#define GAUSS_RADIUS 1
const float gaussKernel[9] = float[9](1.0/16.0, 1.0/8.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/8.0, 1.0/16.0, 1.0/8.0, 1.0/16.0);
const float gaussian_kernel[3][3] = {
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
	{ 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
	{ 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
};

bool eps_equal(float a, float b){
  return round(a) == round(b);
}

float
compute_sigma_luminance(float center, ivec2 ipos, int addr)
{
	const int r = GAUSS_RADIUS;

	float sum = center * gaussian_kernel[0][0];

	for(int yy = -r; yy <= r; yy++) {
		for(int xx = -r; xx <= r; xx++) {
			if(xx != 0 || yy != 0) {
				ivec2 p = ipos + ivec2(xx, yy);
				float v = imageLoad(gbuffers[addr], p).a; // POSSIBLE BUG HERE...
				float w = gaussian_kernel[xx + 1][yy + 1];
				sum += v * w;
			}
		}
	}

	return sqrt(max(sum, 0.0));
}

void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    int minor_iteration = push.consts.iteration % 2;
    int major_iteration = push.consts.iteration;

    const int d_addr_0 = ((minor_iteration%2) != 0) ? DIFFUSE_ILLUM_VAR_ADDR : ATROUS_HISTORY_1_ADDR;
    const int d_addr_1 = ((minor_iteration%2) != 0) ? ATROUS_HISTORY_1_ADDR : DIFFUSE_ILLUM_VAR_ADDR;
    const int i_addr_0 = ((minor_iteration%2) != 0) ? SPECULAR_ILLUM_VAR_ADDR : ATROUS_HISTORY_2_ADDR;
    const int i_addr_1 = ((minor_iteration%2) != 0) ? ATROUS_HISTORY_2_ADDR : SPECULAR_ILLUM_VAR_ADDR;

    float p_variance = imageLoad(gbuffers[VARIANCE_ADDR], ipos).r;
    int p_samples = int(imageLoad(gbuffers[SAMPLE_COUNT_ADDR], ipos).r);
    vec4 p_pos_dep_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    vec4 p_norm_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos);
    vec4 p_lum_var_data = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR], ipos);
    vec4 p_uv_met_rough = imageLoad(gbuffers[UV_METALLIC_ROUGHESS_ADDR],  ipos);
    vec4 p_direct_var = imageLoad(gbuffers[d_addr_0], ipos); // BUG HERE...
    vec4 p_indirect_var = imageLoad(gbuffers[i_addr_0], ipos);
    float l_p = luminance(p_direct_var.rgb) + luminance(p_indirect_var.rgb);

    int curr_step_width = 1 << major_iteration;
    float l_sigma = compute_sigma_luminance(p_direct_var.a, ipos, d_addr_0) * 3.0 * push.consts.parameter1; 
    float n_sigma = 128.0 * push.consts.parameter1; 
    float p_sigma = 1.0 * push.consts.parameter1; 

    l_sigma = ((major_iteration+1) * l_sigma);
    n_sigma = ((major_iteration+1) * n_sigma);
    p_sigma = ((major_iteration+1) * p_sigma);

    vec3 sum_direct = vec3(0.0);
    vec3 sum_indirect = vec3(0.0);
    float sum_var = EPSILON;
    float weights = EPSILON;

    if (int(p_norm_id_data.w) != -1) {
        for (int yy = -RADIUS; yy <= RADIUS; ++yy){
            for (int xx = -RADIUS; xx <= RADIUS; ++xx) {
                ivec2 offset = ivec2(xx, yy) * curr_step_width;
                ivec2 st = ipos + offset;
                if ((st.x < 0) || (st.y < 0) || 
                    (st.x >= push.consts.width) 
                    || (st.y >= push.consts.height)) continue;

                vec4 q_direct_var = imageLoad(gbuffers[d_addr_0], ivec2(st));
                vec4 q_indirect_var = imageLoad(gbuffers[i_addr_0], ivec2(st));
                vec4 q_norm_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], st);
                if (any(isnan(q_direct_var))) continue; 
                if (any(isnan(q_indirect_var))) continue;
                if (!eps_equal(p_norm_id_data.w, q_norm_id_data.w)) continue;
                vec4 q_pos_dep_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], st);

                vec3 t = p_pos_dep_data.xyz - q_pos_dep_data.xyz;
                float dist2 = dot(t, t) + t.z * t.z;
                float l_q = luminance(q_direct_var.rgb) + luminance(q_indirect_var.rgb);
                float wp = min(exp(-(dist2)/p_sigma), 1.0);
                float wn = pow(max(0.0, dot(p_norm_id_data.xyz, q_norm_id_data.xyz)), n_sigma);
                // float wl = clamp(abs(l_q - l_p) / (l_sigma + 1e-10), 0.0, 1.0); 
                if (isnan(l_q)) continue;
                if (isnan(l_p)) continue;
                if (isnan(l_sigma)) continue;
                // float wl = abs(l_q - l_p) / (l_sigma + 1e-10); 
                // float wl = ((xx != 0) && (yy != 0)) ? max(1.0 - l_sigma, 0.0) : 1;
                float wl = 1.0;

                float w = wp * wn *  wl;
                float weight = h[yy + RADIUS][xx + RADIUS] * w;

                sum_direct += weight * q_direct_var.rgb;
                sum_indirect += weight * q_indirect_var.rgb;
                sum_var += weight * q_direct_var.w;
                weights += weight;
            }
        }

        vec3 direct_result;
        vec3 indirect_result;
        float var_result;
        if (weights > EPSILON) {
            var_result = sum_var/weights;
            float alpha = 0.0;//exp(-p_samples);//1.0 - clamp(var_result, 0.0, 1.0); //min(max(uv_metallic_roughness.z, (1.0 - uv_metallic_roughness.w)), 1.0); // note, num_samples is normalized
            direct_result = (alpha * p_direct_var.rgb) + ((1.0 - alpha) * (sum_direct/weights));
            indirect_result = (alpha * p_indirect_var.rgb) + ((1.0 - alpha) * (sum_indirect/weights));
        } else {
            direct_result = p_direct_var.rgb;
            indirect_result = p_indirect_var.rgb;
            var_result = p_direct_var.w;
        }

        /* Cant seem to get this to work yet*/

        // direct_result = clamp(direct_result, 0.0, 10.0);
        // indirect_result = clamp(indirect_result, 0.0, 10.0);
        if (any(isnan(direct_result))) direct_result = vec3(0.);
        if (any(isnan(indirect_result))) indirect_result = vec3(0.);
        if (isnan(var_result)) var_result = 1.;
        if (isinf(var_result)) var_result = 1.;
        
        imageStore(gbuffers[d_addr_1], ipos, vec4(direct_result.rgb, var_result));
        imageStore(gbuffers[i_addr_1], ipos, vec4(indirect_result.rgb, var_result));
    }
}

#version 460
#pragma optionNV (unroll all)

#define COMPUTE

#include "Pluto/Resources/Shaders/Common/Descriptors.hxx"
#include "Pluto/Resources/Shaders/Common/ShaderConstants.hxx"


layout (local_size_x = 16, local_size_y = 16) in;
/*
In my engine, this is the HDR image that we get AFTER the deferred lighting has been done,
and BEFORE the tonemapping is applied.
hdrTex = HDR image of current frame
histHdrTex = HDR image of previous frame.
*/

#define RADIUS 1

void main() {
    vec2 gid = gl_GlobalInvocationID.xy;
    const int curr_hist_addr = ((push.consts.frame % 2) == 0) ? TAA_HISTORY_1_ADDR : TAA_HISTORY_2_ADDR; 
    const int next_hist_addr = ((push.consts.frame % 2) == 0) ? TAA_HISTORY_2_ADDR : TAA_HISTORY_1_ADDR; 

    // first frame, no blending at all.
    if (push.consts.frame > 10) {
        /* Compute neighborhood min and max */
        vec3 nmin = vec3(0.0), nmax = vec3(0.0);
        vec3 current_color;
        for (int y = -RADIUS; y <= RADIUS; ++y) {
            for (int x = -RADIUS; x <= RADIUS; ++x) {
                vec3 color = imageLoad(render_image, ivec2(gid) + ivec2(x, y)).rgb;
                if ((x == 0) && (y == 0)) current_color = color;
                if ((y == -RADIUS) && (x == -RADIUS)) {
                    nmin = nmax = color;
                }
                else {
                    nmin = min(nmin, color); nmax = max(nmax, color);
                }
            }
        }
    
        float blend = 0.1;
        vec4 motion_data = imageLoad(gbuffers[MOTION_ADDR], ivec2(gid));
        if (motion_data.w > 0) blend = 1.0;
        vec2 v = motion_data.xy;
        v = v * vec2(.5, -.5);
        vec2 histUv = (vec2(gid.xy) / vec2(push.consts.width, push.consts.height)) + v.xy;
        vec2 fudge_factor = vec2(.5, .5); // Some weirdness with numerical precision. This seems to fix slight drift in motion vectors
        ivec2 ihistUv = ivec2(floor(vec2(gid.xy) + (v.xy * vec2(push.consts.width, push.consts.height) + fudge_factor) ));

        // sample from history buffer, with neighbourhood clamping.  
        vec3 hist_color = (blend < 1.0) ? clamp(imageLoad(gbuffers[curr_hist_addr], ivec2(gid)).rgb, nmin, nmax) : vec3(0.0);
        // vec3 color = texture(sampler2D(gbuffer_textures[curr_direct_hist_addr], samplers[0]), histUv + vec2(x/push.consts.width, y/push.consts.height)).rgb;//  imageLoad(gbuffers[9], histUv + ivec2(x, y)).rgb;

        // Avoid nans
        if (any(isnan(hist_color))) {blend = 1.0; hist_color = vec3(0.0);}

        /* Dont blend if motion vector falls out of the screen */
        bvec2 a = greaterThan(histUv, vec2(1.0, 1.0));
        bvec2 b = lessThan(histUv, vec2(0.0, 0.0));
        blend = any(bvec2(any(a), any(b))) ? 1.0 : blend;
                
        // finally, blend current and clamped history sample.
        hist_color = mix(hist_color, current_color, vec3(blend));

        imageStore(render_image, ivec2(gl_GlobalInvocationID.xy), vec4(hist_color, 1.0));
        imageStore(gbuffers[next_hist_addr], ivec2(gl_GlobalInvocationID.xy), vec4(hist_color, 1.0));
    }  
    else {
        /* Set history to current value */
        vec3 currVal = imageLoad(render_image, ivec2(gl_GlobalInvocationID.xy)).rgb;
        imageStore(gbuffers[next_hist_addr], ivec2(gl_GlobalInvocationID.xy), vec4(currVal, 1.0));
    }
}

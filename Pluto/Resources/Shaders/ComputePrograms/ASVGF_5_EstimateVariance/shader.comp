#version 460
// We're interested in computing the temporal gradient for the current frame i
// at a forward projected pixel location j.

// This cam be computed by taking the difference between two shading sample 
// functions, f_[i] - f_[i-1]

// This shading sample function is parameterized by a surface sample G and a 
// random seed S

// Specificly, the current shading sample function f_[i] is parameterized by the
// surface sample G from the frame i-1, forward projected to the current frame
// using motion vectors. It's parameterized by a seed as well, which is 
// forward projected to the current frame.

// The previous shading sample function f_[i-1] is parameterized by the surface 
// sample G from the frame i-1 (not forward projected), and by the seed from 
// the previous frame i-1 (also not forward projected). The result of this 
// shading sample function is the sample from the previous frame.

// Note that only a subset of the previous samples satisfy the above criteria.
// specifically, only a subset use reprojected samples.

// In practice, we only care about the luminance of the sample from the previous
// frame, which is stored alongside the seed.

#define COMPUTE

#include "Pluto/Resources/Shaders/Common/Descriptors.hxx"
#include "Pluto/Resources/Shaders/Common/ShaderConstants.hxx"
#include "Pluto/Resources/Shaders/Common/Random.hxx"
#include "Pluto/Resources/Shaders/Common/Utilities.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

void main()
{
	const int max_rad = 3 * PATH_TRACE_TILE_SIZE;
	const float hist_len_thresh = max_rad + MIN_SAMPLES;

	ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    vec2 moments = imageLoad(gbuffers[LUMINANCE_VARIANCE_ADDR_PREV], ipos).rg;
    float histlen = imageLoad(gbuffers[SAMPLE_COUNT_ADDR_PREV], ipos).a;
	vec4 current_position_depth_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ipos);
    vec4 motion_data = imageLoad(gbuffers[MOTION_ADDR], ipos);

	vec4 direct = vec4(0.); 
	vec4 indirect = vec4(0.); 

	vec4 normal_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], ipos);
	vec3 n_center = normal_id_data.xyz;
	int mesh_id_center = int(normal_id_data.w);

	// TODO if history_length < 4, estimate variance spatially
	if( ((histlen < hist_len_thresh) && (mesh_id_center != -1))) {
		float alpha = (hist_len_thresh - clamp(histlen, 0, hist_len_thresh) ) / hist_len_thresh;
		float sum_w = 0.0;
		float sum_m_w = 0.0;
		const int r = int(mix(0, max_rad, alpha)) * 2;
		for(int yy = -r; yy <= r; yy++) {
			for(int xx = -r; xx <= r; xx++) {
				ivec2 p = ipos + ivec2(xx, yy) * PATH_TRACE_TILE_SIZE;
				vec4 d_p = imageLoad(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], p);
				vec4 i_p = imageLoad(gbuffers[SPECULAR_ILLUM_VAR_ADDR], p);

				float ld = luminance(d_p.rgb);
				float li = luminance(i_p.rgb);
				float l = ld + li;

				vec4 curr_pos_depth_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], p);
				float z_p = curr_pos_depth_data.w;
				vec4 curr_norm_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], p);
				vec3 n_p = curr_norm_id_data.xyz;

				float w_z = 1.0;//abs(z_p - z_center.x) / (z_center.y * length(vec2(xx, yy)) + 1e-2);
				float w_n = pow(max(0, dot(n_p, n_center)), 128.0); 

				int mesh_id_p = int(curr_norm_id_data.w);

				float w = exp(-w_z) * w_n * (mesh_id_center == mesh_id_p ? 1.0 : 0.0);
				
				if(isnan(w)) continue;

				sum_m_w += w;
				moments += vec2(l, l * l) * w;
				
				w *= exp(-pow(length(vec2(xx,yy)), 2) / (pow(max(r,1)*.5, 2)));
				sum_w += w;

				direct.rgb += d_p.rgb * w;
				indirect.rgb += i_p.rgb * w;
			}
		}

		if (sum_m_w > 0) {
			moments /= sum_m_w;
		}
		if (sum_w > 0) {
			direct.rgb /= sum_w;
			indirect.rgb /= sum_w;
		}
			
		float variance_temporal = abs(moments.y - moments.x * moments.x);
        imageStore(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], ipos, vec4(direct.rgb, variance_temporal));
        imageStore(gbuffers[SPECULAR_ILLUM_VAR_ADDR], ipos, vec4(indirect.rgb, variance_temporal));
	}
	else if (mesh_id_center == -1)
	{
		direct = imageLoad(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], ipos);
		indirect = imageLoad(gbuffers[SPECULAR_ILLUM_VAR_ADDR], ipos);
        imageStore(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], ipos, vec4(direct.rgb, 0));
        imageStore(gbuffers[SPECULAR_ILLUM_VAR_ADDR], ipos, vec4(indirect.rgb, 0));
		return;
	}
	else {
		direct = imageLoad(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], ipos);
		indirect = imageLoad(gbuffers[SPECULAR_ILLUM_VAR_ADDR], ipos);
		float variance_temporal = max(0.0, moments.y - moments.x * moments.x);
        imageStore(gbuffers[DIFFUSE_ILLUM_VAR_ADDR], ipos, vec4(direct.rgb, variance_temporal));
        imageStore(gbuffers[SPECULAR_ILLUM_VAR_ADDR], ipos, vec4(indirect.rgb, variance_temporal));
    }
}

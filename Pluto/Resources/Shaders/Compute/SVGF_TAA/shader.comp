#version 460

#define COMPUTE

#include "Pluto/Resources/Shaders/Descriptors.hxx"
#include "Pluto/Resources/Shaders/ShaderConstants.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

#define RADIUS 2

float Coefficients[25] = 
{
    0.003765,	0.015019,	0.023792,	0.015019,	0.003765,
    0.015019,	0.059912,	0.094907,	0.059912,	0.015019,
    0.023792,	0.094907,	0.150342,	0.094907,	0.023792,
    0.015019,	0.059912,	0.094907,	0.059912,	0.015019,
    0.003765,	0.015019,	0.023792,	0.015019,	0.003765,
};

/* Temporal SVGF filter over demodulated direct and indirect illumination */
void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    const int direct_illum_addr = DEMOD_DIRECT_ADDR;
    const int indirect_illum_addr = DEMOD_INDIRECT_ADDR;
    const int curr_direct_hist_addr = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_1_ADDR : SVGF_TAA_HISTORY_2_ADDR;
    const int next_direct_hist_addr = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_2_ADDR : SVGF_TAA_HISTORY_1_ADDR;
    const int curr_indirect_hist_addr = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_3_ADDR : SVGF_TAA_HISTORY_4_ADDR;
    const int next_indirect_hist_addr = ((push.consts.frame % 2) == 0) ? SVGF_TAA_HISTORY_4_ADDR : SVGF_TAA_HISTORY_3_ADDR;

    // first frame, no blending at all.
    if (push.consts.frame < 10) {
        /* Set history to current value */
        vec3 currDirectVal = imageLoad(gbuffers[DEMOD_DIRECT_ADDR], gid).rgb;
        vec3 currIndirectVal = imageLoad(gbuffers[DEMOD_INDIRECT_ADDR], gid).rgb;
        imageStore(gbuffers[next_direct_hist_addr], gid, vec4(currDirectVal, 1.0));
        imageStore(gbuffers[next_indirect_hist_addr], gid, vec4(currIndirectVal, 1.0));
    }
    else {
        int valid_samples = 0;
        float blend = 0.1;
        vec4 motion_data = imageLoad(gbuffers[MOTION_ADDR], ivec2(gid));
        if (motion_data.w > 0) blend = 1.0; // reset history if motion data is invalid
        
        vec2 v = motion_data.xy * vec2(.5, -.5);
        vec2 histUv = (vec2(gid.xy) / vec2(push.consts.width, push.consts.height)) + v.xy;
        vec2 fudge_factor = vec2(.5, .5); // Some weirdness with numerical precision. This seems to fix slight drift in motion vectors
        ivec2 ihistUv = ivec2(floor(vec2(gid.xy) + (v.xy * vec2(push.consts.width, push.consts.height) + fudge_factor) ));
        
        vec3 current_direct = imageLoad(gbuffers[DEMOD_DIRECT_ADDR], ivec2(gid)).rgb;
        vec3 current_indirect = imageLoad(gbuffers[DEMOD_INDIRECT_ADDR], ivec2(gid)).rgb;
        vec4 current_albedo_data = imageLoad(gbuffers[ALBEDO_ADDR], ivec2(gid));
        vec4 current_normal_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR], ivec2(gid));
        vec3 current_albedo = current_albedo_data.rgb;
        int current_entity_id = int(current_normal_id_data.a);
        vec4 current_position_depth_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR], ivec2(gid));
        vec3 current_pos = current_position_depth_data.xyz;
        float current_dist = current_position_depth_data.w;

        vec3 hist_direct = vec3(0);
        vec3 hist_indirect = vec3(0);

        float cum_weight = 0.0;
        if (blend != 1.0) {
            for (int y = -RADIUS; y <= RADIUS; ++y) {
                for (int x = -RADIUS; x <= RADIUS; ++x) {
                    float coefficient = Coefficients[(x + RADIUS) + (y + RADIUS) * (2 * RADIUS + 1)];

                    /* Dont blend if motion vector falls out of the screen */
                    bvec2 a = greaterThan(ihistUv + ivec2(x, y), vec2(push.consts.width-1, push.consts.height-1));
                    bvec2 b = lessThan(ihistUv + ivec2(x, y), vec2(0.0, 0.0));
                    if (any(bvec2(any(a), any(b)))) continue;
                    
                    /* Dont blend nans or infs */
                    vec3 direct = imageLoad(gbuffers[curr_direct_hist_addr], ihistUv + ivec2(x, y)).rgb;
                    // vec3 direct = texture(sampler2D(gbuffer_textures[curr_direct_hist_addr], samplers[0]), histUv + vec2(x/push.consts.width, y/push.consts.height)).rgb;
                    if (any(isnan(direct))) continue;
                    if (any(isinf(direct))) continue;

                    vec3 indirect = imageLoad(gbuffers[curr_indirect_hist_addr], ihistUv + ivec2(x, y)).rgb;
                    // vec3 indirect = texture(sampler2D(gbuffer_textures[curr_indirect_hist_addr], samplers[0]), histUv + vec2(x/push.consts.width, y/push.consts.height)).rgb;
                    if (any(isnan(indirect))) continue;
                    if (any(isinf(indirect))) continue;
                    
                    vec4 hist_albedo_data = imageLoad(gbuffers[ALBEDO_ADDR_PREV], ihistUv + ivec2(x, y));
                    vec3 hist_albedo = hist_albedo_data.rgb;
                    vec4 hist_normal_id_data = imageLoad(gbuffers[NORMAL_ID_ADDR_PREV], ihistUv + ivec2(x, y));
                    int hist_entity_id = int(hist_normal_id_data.a);
                    
                    /* Different objects should not be blended */
                    if (hist_entity_id != current_entity_id) continue;
                    if (distance(hist_albedo,  current_albedo) > .1) continue;

                    vec4 hist_pos_data = imageLoad(gbuffers[POSITION_DEPTH_ADDR_PREV], ihistUv + ivec2(x, y));
                    vec3 hist_pos = hist_pos_data.xyz;
                    float hist_dist = hist_pos_data.w;

                    if (abs(hist_dist - current_dist) > .5) continue;
                    if (distance(hist_pos,  current_pos) > .5) continue;

                    cum_weight += coefficient;

                    valid_samples++;
                    hist_direct += coefficient*direct;
                    hist_indirect += coefficient*indirect;
                }
            }
        }

        if (valid_samples > 0) {
            hist_direct /= cum_weight;
            hist_indirect /= cum_weight;
        }

        if (valid_samples == 0) blend = 1.0; // Dont blend if we didnt find a good sample...

        // finally, blend current and history samples.
        hist_direct = mix(hist_direct, current_direct, vec3(blend));
        hist_indirect = mix(hist_indirect, current_indirect, vec3(blend));

        imageStore( gbuffers[DEMOD_DIRECT_ADDR],       ivec2(gl_GlobalInvocationID.xy), vec4(hist_direct, 1.0));
        imageStore( gbuffers[DEMOD_INDIRECT_ADDR],     ivec2(gl_GlobalInvocationID.xy), vec4(hist_indirect, 1.0));
        imageStore( gbuffers[next_direct_hist_addr],   ivec2(gl_GlobalInvocationID.xy), vec4(hist_direct, 1.0));
        imageStore( gbuffers[next_indirect_hist_addr], ivec2(gl_GlobalInvocationID.xy), vec4(hist_indirect, 1.0));
    }
}

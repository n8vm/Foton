#version 460

/* Denoises raw color data before being fed into the geometric TAA */

#define COMPUTE

#include "Pluto/Resources/Shaders/Descriptors.hxx"
#include "Pluto/Resources/Shaders/ShaderConstants.hxx"

layout (local_size_x = 16, local_size_y = 16) in;

ivec2 offsets[25] = { ivec2(-2, -2), ivec2(-1, -2), ivec2(0, -2), ivec2(1, -2), ivec2(2, -2), ivec2(-2, -1), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1), ivec2(2, -1), ivec2(-2, 0), ivec2(-1, 0), ivec2(0, 0), ivec2(1, 0), ivec2(2, 0), ivec2(-2, 1), ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(-2, 2), ivec2(-1, 2), ivec2(0, 2), ivec2(1, 2), ivec2(2, 2)
};

float kernel[25] = {
    1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0,
    1.0 / 256.0, 1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0, 3.0 / 128.0,
    3.0 / 32.0, 9.0 / 64.0, 3.0 / 32.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0,
    1.0 / 16.0, 1.0 / 64.0, 1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0
};

void main() {
    int iteration = push.consts.iteration;

    const int max_diffuse_iteration = 10;

    const int d_addr_0 = ((iteration%2) == 0) ? DIRECT_ILLUM_ADDR : ATROUS_HISTORY_1_ADDR;
    const int i_addr_0 = ((iteration%2) == 0) ? INDIRECT_ILLUM_ADDR : ATROUS_HISTORY_2_ADDR;
    const int d_addr_1 = ((iteration%2) == 0) ? ATROUS_HISTORY_1_ADDR : DIRECT_ILLUM_ADDR;
    const int i_addr_1 = ((iteration%2) == 0) ? ATROUS_HISTORY_2_ADDR : INDIRECT_ILLUM_ADDR;

    const int p_addr = POSITION_DEPTH_ADDR;
    const int n_addr = NORMAL_ID_ADDR_PREV;
    const int c_addr = ALBEDO_ADDR;
    
    vec3 sum_direct = vec3(0.0);
    vec3 sum_indirect = vec3(0.0);

    int stepwidth = (1 << (push.consts.iteration + 1)) - 1;
    float c_phi = push.consts.parameter1; 
    float n_phi = push.consts.parameter1; 
    float p_phi = push.consts.parameter1; 

    c_phi = 1. / ((1 << push.consts.iteration) * c_phi); // TODO, upload this...
    n_phi = 1. / ((1 << push.consts.iteration) * n_phi); // TODO, upload this...
    p_phi = 1. / ((1 << push.consts.iteration) * p_phi); // TODO, upload this...

    vec2 gid = gl_GlobalInvocationID.xy;
    int entity_id = int(imageLoad(gbuffers[n_addr], ivec2(gid)).w);

    if (entity_id != -1) {
        vec4 direct = (iteration <= max_diffuse_iteration) ? imageLoad(gbuffers[d_addr_0], ivec2(gid)) : vec4(0);
        vec4 indirect = imageLoad(gbuffers[i_addr_0], ivec2(gid));
        vec3 pval = imageLoad(gbuffers[p_addr], ivec2(gid)).xyz;
        vec3 nval = imageLoad(gbuffers[n_addr], ivec2(gid)).xyz;
        vec3 cval = imageLoad(gbuffers[c_addr], ivec2(gid)).xyz;
        float cum_w = EPSILON;

        for (int i = 0; i < 25; i++) {
            ivec2 st = ivec2(gid) + offsets[i] * stepwidth;
            
            vec3 tmp_direct = (iteration <= max_diffuse_iteration) ? imageLoad(gbuffers[d_addr_0], ivec2(st)).rgb : vec3(0);
            vec3 tmp_indirect = imageLoad(gbuffers[i_addr_0], ivec2(st)).rgb;
            
            // just in case...
            if (any(isnan(tmp_direct))) tmp_direct = vec3(0.0); 
            if (any(isnan(tmp_indirect))) tmp_indirect = vec3(0.0); // just in case...

            vec3 ctmp = imageLoad(gbuffers[c_addr], ivec2(st)).xyz;
            vec3 t = cval - ctmp;
            float dist2 = dot(t,t);
            float c_w = min(exp(-(dist2)/c_phi), 1.0);

            vec3 ntmp = imageLoad(gbuffers[n_addr], st).xyz;
            t = nval - ntmp;
            dist2 = max(dot(t,t)/float(stepwidth*stepwidth), 0.0);
            float n_w = min(exp(-(dist2)/n_phi), 1.0);
 
            vec3 ptmp = imageLoad(gbuffers[p_addr], st).xyz;
            t = pval - ptmp;
            dist2 = dot(t,t);
            float p_w = min(exp(-(dist2)/p_phi),1.0);

            float weight = c_w*n_w*p_w;
            sum_direct += tmp_direct*weight*kernel[i];
            sum_indirect += tmp_indirect*weight*kernel[i];
            cum_w += weight*kernel[i];
        }

        vec3 direct_result = (iteration > 2) ? direct.rgb : sum_direct/cum_w;
        vec3 indirect_result = sum_indirect/cum_w;

        if (any(isnan(direct_result))) direct_result = direct.rgb; // just in case...
        if (any(isnan(indirect_result))) indirect_result = indirect.rgb; // just in case...

        imageStore(gbuffers[d_addr_1], ivec2(gid), vec4(direct_result.rgb, direct.a));
        if (iteration <= max_diffuse_iteration) {
            imageStore(gbuffers[i_addr_1], ivec2(gid), vec4(indirect_result.rgb, indirect.a));
        }
    }
}
